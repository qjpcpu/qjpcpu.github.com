<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: shell | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2014-03-06T00:19:01+08:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[curl]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/03/05/curl/"/>
    <updated>2014-03-05T23:29:56+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/03/05/curl</id>
    <content type="html"><![CDATA[<h3>基本用法</h3>

<p><code>bash
curl http://www.google.com
curl --proxy http://proxy.com:8888 http://ww.google.com #使用代理
curl http://user:password@example.org/  #http验证
curl -u user:password http://example.org/ #http验证
</code>
获取响应头</p>

<p><code>bash
curl -i http://example.com  #在返回结果中包含响应头
curl -IL http://example.com  #仅返回响应头
</code></p>

<!--more-->


<h3>REST请求</h3>

<p><strong>GET</strong></p>

<p><code>bash
curl http://www.google.com
</code></p>

<p><strong>POST</strong></p>

<p>```bash
curl &mdash;data &ldquo;birthyear=1905&amp;press=%20OK%20&rdquo;  <a href="http://www.example.com/when.cgi">http://www.example.com/when.cgi</a></p>

<h1>or</h1>

<p>curl &mdash;data-urlencode &ldquo;name=I am Daniel&rdquo; <a href="http://www.example.com">http://www.example.com</a>
```</p>

<p><strong>PUT</strong></p>

<p><code>bash
curl --upload-file uploadfile http://www.example.com/receive.cgi #upload a file
</code></p>

<p><strong>DELETE</strong></p>

<p>实际上，可以用<code>curl -X http_method</code>指定包括GET,POST,PUT内的任意方法</p>

<p><code>bash
curl -X DELETE http://example.com
</code></p>

<h3>header</h3>

<p>使用-H或&mdash;header指定请求头部</p>

<p><code>bash
curl -H "Content-Type: application/json" http:/example.com
</code></p>

<h3>Cookie</h3>

<p><code>-b,--cookie</code>选项告诉<code>curl</code>使用已有的cookie，可以是键值对也可以是文件</p>

<p><code>bash
curl -b "name=value" http://host
curl -b cookie.txt http://host.com
</code></p>

<p><code>-c,--cookie-jar</code>选项告诉<code>curl</code>将新的cookie保存在文件中</p>

<p><code>bash
curl -c new.txt http://example.com
</code></p>

<h3>HTTPS</h3>

<p><code>bash
curl https://example.com
curl --cert mycert.pem https://example.com
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[列出目录结构]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/27/lie-chu-mu-lu-jie-gou/"/>
    <updated>2014-02-27T20:52:50+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/27/lie-chu-mu-lu-jie-gou</id>
    <content type="html"><![CDATA[<h3>最简单美观的方法tree</h3>

<p>tree命令是专门用来罗列目录结构的，输出树形结果，很漂亮。</p>

<p>```bash
$ tree demo
demo
├── Gemfile
├── boot.rb
├── collectors
├── config
│   └── mail_config.rb
├── controllers
├── db
│   ├── connection.rb
│   ├── database.yml
│   └── migrate
├── helpers
├── models
├── rakefile
└── views</p>

<p>8 directories, 6 files
```</p>

<!--more-->


<h3>折衷的方法find</h3>

<p>如果没有权限在机器上安装tree命令，find命令也是一种折衷的选择。</p>

<p><code>bash
$ find demo -type f -o -type d
demo
demo/boot.rb
demo/collectors
demo/config
demo/config/.gitkeep
demo/config/mail_config.rb
demo/controllers
demo/db
demo/db/connection.rb
demo/db/database.yml
demo/db/migrate
demo/db/migrate/.gitkeep
demo/Gemfile
demo/helpers
demo/helpers/.gitkeep
demo/models
demo/rakefile
demo/views
</code></p>

<p>虽然没有tree命令那么直观，但却有另一个好处，便于使用管道进一步操作。</p>

<h3>仅仅是一种选择ls</h3>

<p>ls命令也可以罗列出目录结构，但这个仅供娱乐了。</p>

<p>```bash
$ ls -R demo
Gemfile     collectors  controllers helpers     rakefile
boot.rb     config      db      models      views</p>

<p>demo/collectors:</p>

<p>demo/config:
mail_config.rb</p>

<p>demo/controllers:</p>

<p>demo/db:
connection.rb   database.yml    migrate</p>

<p>demo/db/migrate:</p>

<p>demo/helpers:</p>

<p>demo/models:</p>

<p>demo/views:
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[find命令]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/27/findming-ling/"/>
    <updated>2014-02-27T20:10:37+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/27/findming-ling</id>
    <content type="html"><![CDATA[<h3>find的基本语法</h3>

<p><code>bash
find PATH OPTIONS [-exec COMMANDD {} \;]
</code></p>

<p><code>find</code>命令可以使用多个OPTION，不同OPTION之间默认是<code>and</code>关系，除了<code>and</code>关系还有<code>not</code>和<code>or</code>关系，如：</p>

<p><code>bash
find / -name 'n1' -type f  #查找/目录下名称为n1且为普通文件的文件
find / -name 'n1' -o -name 'n2' #查找名称为n1或n2的文件
find / ! -name 'n1'  # 查找名称不为n1的文件
</code></p>

<p>当使用的OPTION很多时，可以将OPTIONS括起来增加可读性，注意括号需要用<code>\</code>来转义，同时<code>\(</code>和<code>\)</code>两边都需要有空格：</p>

<p><code>bash
find / \( -name 'n1' -o -name 'n2' \)
</code></p>

<!--more-->


<h3>find命令常用的OPTION</h3>

<ul>
<li>-name  按名称查找，支持通配符*,?,[]</li>
<li>-user  按用户名查找</li>
<li>-empty  查找空文件(目录)</li>
<li>-perm  查找对应权限的文件，权限表示的三位数字形式如777</li>
<li>-type 按类型查找，类型可为<code>b</code>块设备，<code>c</code>字符设备，<code>p</code>管道，<code>f</code>普通文件，<code>l</code>链接文件，<code>s</code>socket文件</li>
<li>-print  打印结果</li>
<li>-regex 按正则表达式查找，注意该正则匹配属于完全匹配，即如果要查找<code>dir</code>目录下的文件<code>file_23</code>应该用正则表达式<code>.*file_[0-9]+</code>，用<code>file_[0-9]+</code>是匹配不到的，<code>find dir -regex '.*file_[0-9]+</code>是用完整结果即<code>dir/file_23</code>来做和<code>-regex</code>完全匹配的</li>
<li>-maxdepth n  find的最大目录层级查找深度，最小为1</li>
<li>-mindepth n find的最小目录查找深度</li>
</ul>


<p>按时间查找的参数：</p>

<ul>
<li>-amin n  查找n分钟以前被访问（access）的文件</li>
<li>-atime n  查找n天前被访问的文件</li>
<li>-cmin n  查找n分钟前文件元信息被修改（change）的文件</li>
<li>-ctime n  查找n天前文件元信息被修改过的文件</li>
<li>-mmin n  查找n分钟前内容被修改的文件</li>
<li>-mtime n 查找n天前内容被修改的文件</li>
</ul>


<h3>exec</h3>

<p>find命令最后的exec表示对找到的文件执行什么命令，其中<code>{}</code>代表找到的文件，注意<code>{}</code>和<code>\;</code>间有空格。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用expect实现自动登录]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/25/shi-yong-expectshi-xian-zi-dong-deng-lu/"/>
    <updated>2014-02-25T20:13:57+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/25/shi-yong-expectshi-xian-zi-dong-deng-lu</id>
    <content type="html"><![CDATA[<p>网上有很多类似的文章，但很多都是先写expect脚本再从bash里调用expect脚本，
我希望直接在bash脚本里使用expect命令来实现自动登录。</p>

<h3>利用expect命令实现自动登录并执行命令</h3>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>expect -c &lsquo;
spawn ssh USER@HOST &ldquo;commands&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;PASSWORD\r&rdquo; }
}
expect eof
&rsquo;
```</p>

<p>关于expect的命令在网上有很多资料，这里不在赘述。下面讲讲怎么在bash和expect传递变量。</p>

<!--more-->


<h3>获取登录名及登录密码</h3>

<p>从bash中获取变量无非就是获取登录主机及密码，提高代码移植性。这里利用bash的Here document实现。</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>host=&ldquo;USER@HOST&rdquo;
password=&ldquo;PASSWORD&rdquo;
cmd=&ldquo;command_list&rdquo;</p>

<p>expect &lt;&lt;EOF
spawn ssh $host &ldquo;$cmd&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;$password\r&rdquo; }
}
expect eof
EOF
```</p>

<p>bash会自动解析here document中的变量，个人认为这种方式比使用expect的set命令更简便。</p>

<h3>获取登录执行命令结果</h3>

<p>如果希望保持登录，去掉上面代码的<code>ssh</code>后的命令列表并且将<code>expect eof</code>改成<code>interact</code>即可。</p>

<p>但通常我们只是登录到某台机器并执行命令后就返回，同时希望获得命令执行的结果。但上面的代码会混合登录时的部分输出，所以这里可以使用管道过滤一下。</p>

<p>下面的代码展示的怎样获取并输出远程主机的真正命令输出，同时也是一个在here document后接管道操作的例子：</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>host=&ldquo;USER@HOST&rdquo;
password=&ldquo;PASSWORD&rdquo;
cmd=&ldquo;command_list&rdquo;</p>

<p>(expect &lt;&lt;EOF
spawn ssh $host &ldquo;$cmd&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;$password\r&rdquo; }
}
expect eof
EOF
) | awk &lsquo;BEGIN{find=0}
{</p>

<pre><code>if(find){print $0;next}
if($0 ~ /[pP]assword:/){ find=1 }
</code></pre>

<p>}&lsquo;
```</p>

<p>这就是在bash中调用expect自动登录的完整代码了。</p>

<p>P.S. 在here document后接管道操作的几种方法：</p>

<p>```bash</p>

<h1>1</h1>

<p>cat &lt;&lt;EOF | sh
echo 1
EOF</p>

<h1>2</h1>

<p>(cat &lt;&lt;EOF
echo 1
EOF
) | sh</p>

<h1>3</h1>

<p>{
cat&lt;&lt;EOF
echo 1
EOF
} | sh
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sendmail发邮件中文乱码]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/19/sendmailfa-you-jian-zhong-wen-luan-ma/"/>
    <updated>2014-02-19T23:23:15+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/19/sendmailfa-you-jian-zhong-wen-luan-ma</id>
    <content type="html"><![CDATA[<p>如果这是要使用sendmail命令发送的邮件file内容：</p>

<pre><code>Subject:标题
TO:to@example.com
From:from@example
Content-Type:text/html
&lt;html&gt;
    &lt;body&gt;
        邮件内容
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>解决内容乱码</h3>

<p>内容乱码比较好解决，首先内容先使用utf-8编码，然后在修改邮件的<code>Content-Type</code>为：</p>

<pre><code>Content-Type:text/html;charset=UTF-8
</code></pre>

<h3>解决标题乱码</h3>

<p>需要利用base64编码标题内容，例如，如果UTF-8编码的字符串<code>标题</code>进行base64编码后的内容为<code>5qCH6aKY</code>,则邮件标题为：</p>

<pre><code>Subject:=?UTF-8?B?5qCH6aKY?=
</code></pre>

<p>即邮件标题<code>Subject:</code>后字符串格式为："<code>=?UTF-8?B?</code><em>base64编码的utf-8字串</em><code>?=</code>"</p>

<h3>发送邮件</h3>

<p>最后发送文件可以正确显示：</p>

<p><code>bash
cat file | sendmail -t
</code></p>
]]></content>
  </entry>
  
</feed>
