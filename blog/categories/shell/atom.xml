<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: shell | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2014-02-27T21:03:40+08:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[列出目录结构]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/27/lie-chu-mu-lu-jie-gou/"/>
    <updated>2014-02-27T20:52:50+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/27/lie-chu-mu-lu-jie-gou</id>
    <content type="html"><![CDATA[<h3>最简单美观的方法tree</h3>

<p>tree命令是专门用来罗列目录结构的，输出树形结果，很漂亮。</p>

<p>```bash
$ tree demo
demo
├── Gemfile
├── boot.rb
├── collectors
├── config
│   └── mail_config.rb
├── controllers
├── db
│   ├── connection.rb
│   ├── database.yml
│   └── migrate
├── helpers
├── models
├── rakefile
└── views</p>

<p>8 directories, 6 files
```</p>

<!--more-->


<h3>折衷的方法find</h3>

<p>如果没有权限在机器上安装tree命令，find命令也是一种折衷的选择。</p>

<p><code>bash
$ find demo -type f -o -type d
demo
demo/boot.rb
demo/collectors
demo/config
demo/config/.gitkeep
demo/config/mail_config.rb
demo/controllers
demo/db
demo/db/connection.rb
demo/db/database.yml
demo/db/migrate
demo/db/migrate/.gitkeep
demo/Gemfile
demo/helpers
demo/helpers/.gitkeep
demo/models
demo/rakefile
demo/views
</code></p>

<p>虽然没有tree命令那么直观，但却有另一个好处，便于使用管道进一步操作。</p>

<h3>仅仅是一种选择ls</h3>

<p>ls命令也可以罗列出目录结构，但这个仅供娱乐了。</p>

<p>```bash
$ ls -R demo
Gemfile     collectors  controllers helpers     rakefile
boot.rb     config      db      models      views</p>

<p>demo/collectors:</p>

<p>demo/config:
mail_config.rb</p>

<p>demo/controllers:</p>

<p>demo/db:
connection.rb   database.yml    migrate</p>

<p>demo/db/migrate:</p>

<p>demo/helpers:</p>

<p>demo/models:</p>

<p>demo/views:
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[find命令]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/27/findming-ling/"/>
    <updated>2014-02-27T20:10:37+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/27/findming-ling</id>
    <content type="html"><![CDATA[<h3>find的基本语法</h3>

<p><code>bash
find PATH OPTIONS [-exec COMMANDD {} \;]
</code></p>

<p><code>find</code>命令可以使用多个OPTION，不同OPTION之间默认是<code>and</code>关系，除了<code>and</code>关系还有<code>not</code>和<code>or</code>关系，如：</p>

<p><code>bash
find / -name 'n1' -type f  #查找/目录下名称为n1且为普通文件的文件
find / -name 'n1' -o -name 'n2' #查找名称为n1或n2的文件
find / ! -name 'n1'  # 查找名称不为n1的文件
</code></p>

<p>当使用的OPTION很多时，可以将OPTIONS括起来增加可读性，注意括号需要用<code>\</code>来转义，同时<code>\(</code>和<code>\)</code>两边都需要有空格：</p>

<p><code>bash
find / \( -name 'n1' -o -name 'n2' \)
</code></p>

<!--more-->


<h3>find命令常用的OPTION</h3>

<ul>
<li>-name  按名称查找，支持通配符*,?,[]</li>
<li>-user  按用户名查找</li>
<li>-empty  查找空文件(目录)</li>
<li>-perm  查找对应权限的文件，权限表示的三位数字形式如777</li>
<li>-type 按类型查找，类型可为<code>b</code>块设备，<code>c</code>字符设备，<code>p</code>管道，<code>f</code>普通文件，<code>l</code>链接文件，<code>s</code>socket文件</li>
<li>-print  打印结果</li>
<li>-regex 按正则表达式查找，注意该正则匹配属于完全匹配，即如果要查找<code>dir</code>目录下的文件<code>file_23</code>应该用正则表达式<code>.*file_[0-9]+</code>，用<code>file_[0-9]+</code>是匹配不到的，<code>find dir -regex '.*file_[0-9]+</code>是用完整结果即<code>dir/file_23</code>来做和<code>-regex</code>完全匹配的</li>
<li>-maxdepth n  find的最大目录层级查找深度，最小为1</li>
<li>-mindepth n find的最小目录查找深度</li>
</ul>


<p>按时间查找的参数：</p>

<ul>
<li>-amin n  查找n分钟以前被访问（access）的文件</li>
<li>-atime n  查找n天前被访问的文件</li>
<li>-cmin n  查找n分钟前文件元信息被修改（change）的文件</li>
<li>-ctime n  查找n天前文件元信息被修改过的文件</li>
<li>-mmin n  查找n分钟前内容被修改的文件</li>
<li>-mtime n 查找n天前内容被修改的文件</li>
</ul>


<h3>exec</h3>

<p>find命令最后的exec表示对找到的文件执行什么命令，其中<code>{}</code>代表找到的文件，注意<code>{}</code>和<code>\;</code>间有空格。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用expect实现自动登录]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/25/shi-yong-expectshi-xian-zi-dong-deng-lu/"/>
    <updated>2014-02-25T20:13:57+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/25/shi-yong-expectshi-xian-zi-dong-deng-lu</id>
    <content type="html"><![CDATA[<p>网上有很多类似的文章，但很多都是先写expect脚本再从bash里调用expect脚本，
我希望直接在bash脚本里使用expect命令来实现自动登录。</p>

<h3>利用expect命令实现自动登录并执行命令</h3>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>expect -c &lsquo;
spawn ssh USER@HOST &ldquo;commands&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;PASSWORD\r&rdquo; }
}
expect eof
&rsquo;
```</p>

<p>关于expect的命令在网上有很多资料，这里不在赘述。下面讲讲怎么在bash和expect传递变量。</p>

<!--more-->


<h3>获取登录名及登录密码</h3>

<p>从bash中获取变量无非就是获取登录主机及密码，提高代码移植性。这里利用bash的Here document实现。</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>host=&ldquo;USER@HOST&rdquo;
password=&ldquo;PASSWORD&rdquo;
cmd=&ldquo;command_list&rdquo;</p>

<p>expect &lt;&lt;EOF
spawn ssh $host &ldquo;$cmd&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;$password\r&rdquo; }
}
expect eof
EOF
```</p>

<p>bash会自动解析here document中的变量，个人认为这种方式比使用expect的set命令更简便。</p>

<h3>获取登录执行命令结果</h3>

<p>如果希望保持登录，去掉上面代码的<code>ssh</code>后的命令列表并且将<code>expect eof</code>改成<code>interact</code>即可。</p>

<p>但通常我们只是登录到某台机器并执行命令后就返回，同时希望获得命令执行的结果。但上面的代码会混合登录时的部分输出，所以这里可以使用管道过滤一下。</p>

<p>下面的代码展示的怎样获取并输出远程主机的真正命令输出，同时也是一个在here document后接管道操作的例子：</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>host=&ldquo;USER@HOST&rdquo;
password=&ldquo;PASSWORD&rdquo;
cmd=&ldquo;command_list&rdquo;</p>

<p>(expect &lt;&lt;EOF
spawn ssh $host &ldquo;$cmd&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;$password\r&rdquo; }
}
expect eof
EOF
) | awk &lsquo;BEGIN{find=0}
{</p>

<pre><code>if(find){print $0;next}
if($0 ~ /[pP]assword:/){ find=1 }
</code></pre>

<p>}&lsquo;
```</p>

<p>这就是在bash中调用expect自动登录的完整代码了。</p>

<p>P.S. 在here document后接管道操作的几种方法：</p>

<p>```bash</p>

<h1>1</h1>

<p>cat &lt;&lt;EOF | sh
echo 1
EOF</p>

<h1>2</h1>

<p>(cat &lt;&lt;EOF
echo 1
EOF
) | sh</p>

<h1>3</h1>

<p>{
cat&lt;&lt;EOF
echo 1
EOF
} | sh
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sendmail发邮件中文乱码]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/19/sendmailfa-you-jian-zhong-wen-luan-ma/"/>
    <updated>2014-02-19T23:23:15+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/19/sendmailfa-you-jian-zhong-wen-luan-ma</id>
    <content type="html"><![CDATA[<p>如果这是要使用sendmail命令发送的邮件file内容：</p>

<pre><code>Subject:标题
TO:to@example.com
From:from@example
Content-Type:text/html
&lt;html&gt;
    &lt;body&gt;
        邮件内容
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>解决内容乱码</h3>

<p>内容乱码比较好解决，首先内容先使用utf-8编码，然后在修改邮件的<code>Content-Type</code>为：</p>

<pre><code>Content-Type:text/html;charset=UTF-8
</code></pre>

<h3>解决标题乱码</h3>

<p>需要利用base64编码标题内容，例如，如果UTF-8编码的字符串<code>标题</code>进行base64编码后的内容为<code>5qCH6aKY</code>,则邮件标题为：</p>

<pre><code>Subject:=?UTF-8?B?5qCH6aKY?=
</code></pre>

<p>即邮件标题<code>Subject:</code>后字符串格式为："<code>=?UTF-8?B?</code><em>base64编码的utf-8字串</em><code>?=</code>"</p>

<h3>发送邮件</h3>

<p>最后发送文件可以正确显示：</p>

<p><code>bash
cat file | sendmail -t
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell字符串处理]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/14/shellzi-fu-chuan-chu-li/"/>
    <updated>2014-02-14T18:10:30+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/14/shellzi-fu-chuan-chu-li</id>
    <content type="html"><![CDATA[<h3>1.获取字符串长度</h3>

<pre><code>${#string}
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="hello,world"
[jason@localhost ~]$ echo ${#str}
11
</code></pre>

<h3>2.获取子串</h3>

<pre><code>${string:position}
${string:position:length}
$(string:(-postion)) 如果使用负数，表示从右开始计数，注意负数必须使用括号
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str=ABCDEFGHIJKLMN
[jason@localhost ~]$ echo ${str:1}
BCDEFGHIJKLMN
[jason@localhost ~]$ echo ${str:1:2}
BC
[jason@localhost ~]$ echo ${str:(-2)}
MN
</code></pre>

<!-- more -->


<h3>3.子串切除</h3>

<pre><code>${string#substring} 从左向右切除最短匹配的子串
${stirng##substring} 从左向右切除最长匹配的子串
${string%substring} 从右向左切除最短匹配的子串
${stirng%%substring} 
</code></pre>

<h3>4.字符串正则提取</h3>

<pre><code>echo $string | grep -oE "regexpression”

#awk的match方法利用RSTART和RLENGTH分别保存匹配的起点(从1开始)和匹配到的长度,RSTART同时也是match方法的返回值，如果没找到则RSTART==0,RLENGHT==-1
echo $string | awk '{ match($0,"reg"); print substr(RSTART,RLENGTH)}'
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I am 12 years old"
[jason@localhost ~]$ echo $str | grep -Eo '[0-9]+'
12
[jason@localhost ~]$ str="I am 12 years old"
[jason@localhost ~]$ echo $str | awk '{ if(match($0,"[0-9]+")){ print substr($0,RSTART,RLENGTH) } }'
12
</code></pre>

<h3>5.字符串正则替换</h3>

<pre><code>echo $string | sed -r 's/regexpr/replacement'
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I am 12 years old" 
[jason@localhost ~]$ echo $str | sed -r  "s/ am/'m/"
I'm 12 years old
</code></pre>

<h3>6.分割字符串</h3>

<pre><code>awk
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I_am_12_years_old, and you?"
[jason@localhost ~]$ echo $str | awk -F '_' '{print $3}'
12
[jason@localhost ~]$ echo $str | awk  '{split($1,a,"_");print a[3]}'
12
</code></pre>

<h3>7. 获取索引</h3>

<pre><code>awk '{print match($0,"substring")}'
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I_am_12_years_old, and you?"
[jason@localhost ~]$ echo $str | awk '{print match($0,"[0-9]+")}'
6
</code></pre>

<p>注意这个索引是从1开始的</p>

<h3>8.sed分组</h3>

<p>sed的分组是很好玩的，在替换模式中，“&amp;”代表前面匹配的全部字符串，而反斜杠加数字表示分组。</p>

<pre><code>[jason@localhost ~]$ str="name:jack;age:12"
[jason@localhost ~]$ echo $str | sed -r 's/name:[^;]+/[&amp;]/'
[name:jack];age:12
[jason@localhost ~]$ echo $str | sed -r 's/name:([^;]+)/--\1--/'
--jack--;age:12
</code></pre>

<h3>9.awk常用字符串处理函数</h3>

<pre><code>sub(reg,replacement,string)
gsub(reg,replacement,string)
</code></pre>

<p>将string中匹配正则表达式reg的字符串（全部）替换为replacement</p>

<pre><code>[jason@localhost ~]$ str="name:jack;age:12"
[jason@localhost ~]$ echo $str | awk '{gsub(/a/,"A",$0);print $0}'      
nAme:jAck;Age:12
</code></pre>

<p>&ndash;</p>

<pre><code>index(substring,string) #返回子字符串substring在字符串string中的位置
length(string) #获取字符串的长度
match(string,reg) #获取匹配reg得到的子串在字符串中的位置
split(string,array,separator) #将字符串按分隔符separator分割到array数组中
sprintf("format",expression) #和c语言的sprintf类似
substr(string,position,length)  #获取子字符串
tolower(string)
toupper(string)
</code></pre>

<p>P.S. awk的常见控制语法</p>

<pre><code>exit #退出awk执行
next #跳转到命令块首，并开始下一行数据读入
NF #列数
NR #行号
FS #分隔符
FILENAME #文件名
</code></pre>
]]></content>
  </entry>
  
</feed>
