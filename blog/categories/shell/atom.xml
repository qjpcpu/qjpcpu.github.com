<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: shell | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2014-02-25T20:19:30+08:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用expect实现自动登录]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/25/shi-yong-expectshi-xian-zi-dong-deng-lu/"/>
    <updated>2014-02-25T20:13:57+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/25/shi-yong-expectshi-xian-zi-dong-deng-lu</id>
    <content type="html"><![CDATA[<p>网上有很多类似的文章，但很多都是先写expect脚本再从bash里调用expect脚本，
我希望直接在bash脚本里使用expect命令来实现自动登录。</p>

<h3>利用expect命令实现自动登录并执行命令</h3>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>expect -c &lsquo;
spawn ssh USER@HOST &ldquo;commands&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;PASSWORD\r&rdquo; }
}
expect eof
&rsquo;
```</p>

<p>关于expect的命令在网上有很多资料，这里不在赘述。下面讲讲怎么在bash和expect传递变量。</p>

<!--more-->


<h3>获取登录名及登录密码</h3>

<p>从bash中获取变量无非就是获取登录主机及密码，提高代码移植性。这里利用bash的Here document实现。</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>host=&ldquo;USER@HOST&rdquo;
password=&ldquo;PASSWORD&rdquo;
cmd=&ldquo;command_list&rdquo;</p>

<p>expect &lt;&lt;EOF
spawn ssh $host &ldquo;$cmd&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;$password\r&rdquo; }
}
expect eof
EOF
```</p>

<p>bash会自动解析here document中的变量，个人认为这种方式比使用expect的set命令更简便。</p>

<h3>获取登录执行命令结果</h3>

<p>如果希望保持登录，去掉上面代码的<code>ssh</code>后的命令列表并且将<code>expect eof</code>改成<code>interact</code>即可。</p>

<p>但通常我们只是登录到某台机器并执行命令后就返回，同时希望获得命令执行的结果。但上面的代码会混合登录时的部分输出，所以这里可以使用管道过滤一下。</p>

<p>下面的代码展示的怎样获取并输出远程主机的真正命令输出，同时也是一个在here document后接管道操作的例子：</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>host=&ldquo;USER@HOST&rdquo;
password=&ldquo;PASSWORD&rdquo;
cmd=&ldquo;command_list&rdquo;</p>

<p>(expect &lt;&lt;EOF
spawn ssh $host &ldquo;$cmd&rdquo;
expect {
&ldquo;<em>(yes/no)?&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue }
&ldquo;</em>assword:&rdquo; { send &ldquo;$password\r&rdquo; }
}
expect eof
EOF
) | awk &lsquo;BEGIN{find=0}
{</p>

<pre><code>if(find){print $0;next}
if($0 ~ /[pP]assword:/){ find=1 }
</code></pre>

<p>}&lsquo;
```</p>

<p>这就是在bash中调用expect自动登录的完整代码了。</p>

<p>P.S. 在here document后接管道操作的几种方法：</p>

<p>```bash</p>

<h1>1</h1>

<p>cat &lt;&lt;EOF | sh
echo 1
EOF</p>

<h1>2</h1>

<p>(cat &lt;&lt;EOF
echo 1
EOF
) | sh</p>

<h1>3</h1>

<p>{
cat&lt;&lt;EOF
echo 1
EOF
} | sh
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sendmail发邮件中文乱码]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/19/sendmailfa-you-jian-zhong-wen-luan-ma/"/>
    <updated>2014-02-19T23:23:15+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/19/sendmailfa-you-jian-zhong-wen-luan-ma</id>
    <content type="html"><![CDATA[<p>如果这是要使用sendmail命令发送的邮件file内容：</p>

<pre><code>Subject:标题
TO:to@example.com
From:from@example
Content-Type:text/html
&lt;html&gt;
    &lt;body&gt;
        邮件内容
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>解决内容乱码</h3>

<p>内容乱码比较好解决，首先内容先使用utf-8编码，然后在修改邮件的<code>Content-Type</code>为：</p>

<pre><code>Content-Type:text/html;charset=UTF-8
</code></pre>

<h3>解决标题乱码</h3>

<p>需要利用base64编码标题内容，例如，如果UTF-8编码的字符串<code>标题</code>进行base64编码后的内容为<code>5qCH6aKY</code>,则邮件标题为：</p>

<pre><code>Subject:=?UTF-8?B?5qCH6aKY?=
</code></pre>

<p>即邮件标题<code>Subject:</code>后字符串格式为："<code>=?UTF-8?B?</code><em>base64编码的utf-8字串</em><code>?=</code>"</p>

<h3>发送邮件</h3>

<p>最后发送文件可以正确显示：</p>

<p><code>bash
cat file | sendmail -t
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell字符串处理]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/14/shellzi-fu-chuan-chu-li/"/>
    <updated>2014-02-14T18:10:30+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/14/shellzi-fu-chuan-chu-li</id>
    <content type="html"><![CDATA[<h3>1.获取字符串长度</h3>

<pre><code>${#string}
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="hello,world"
[jason@localhost ~]$ echo ${#str}
11
</code></pre>

<h3>2.获取子串</h3>

<pre><code>${string:position}
${string:position:length}
$(string:(-postion)) 如果使用负数，表示从右开始计数，注意负数必须使用括号
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str=ABCDEFGHIJKLMN
[jason@localhost ~]$ echo ${str:1}
BCDEFGHIJKLMN
[jason@localhost ~]$ echo ${str:1:2}
BC
[jason@localhost ~]$ echo ${str:(-2)}
MN
</code></pre>

<!-- more -->


<h3>3.子串切除</h3>

<pre><code>${string#substring} 从左向右切除最短匹配的子串
${stirng##substring} 从左向右切除最长匹配的子串
${string%substring} 从右向左切除最短匹配的子串
${stirng%%substring} 
</code></pre>

<h3>4.字符串正则提取</h3>

<pre><code>echo $string | grep -oE "regexpression”

#awk的match方法利用RSTART和RLENGTH分别保存匹配的起点(从1开始)和匹配到的长度,RSTART同时也是match方法的返回值，如果没找到则RSTART==0,RLENGHT==-1
echo $string | awk '{ match($0,"reg"); print substr(RSTART,RLENGTH)}'
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I am 12 years old"
[jason@localhost ~]$ echo $str | grep -Eo '[0-9]+'
12
[jason@localhost ~]$ str="I am 12 years old"
[jason@localhost ~]$ echo $str | awk '{ if(match($0,"[0-9]+")){ print substr($0,RSTART,RLENGTH) } }'
12
</code></pre>

<h3>5.字符串正则替换</h3>

<pre><code>echo $string | sed -r 's/regexpr/replacement'
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I am 12 years old" 
[jason@localhost ~]$ echo $str | sed -r  "s/ am/'m/"
I'm 12 years old
</code></pre>

<h3>6.分割字符串</h3>

<pre><code>awk
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I_am_12_years_old, and you?"
[jason@localhost ~]$ echo $str | awk -F '_' '{print $3}'
12
[jason@localhost ~]$ echo $str | awk  '{split($1,a,"_");print a[3]}'
12
</code></pre>

<h3>7. 获取索引</h3>

<pre><code>awk '{print match($0,"substring")}'
</code></pre>

<p>&ndash;</p>

<pre><code>[jason@localhost ~]$ str="I_am_12_years_old, and you?"
[jason@localhost ~]$ echo $str | awk '{print match($0,"[0-9]+")}'
6
</code></pre>

<p>注意这个索引是从1开始的</p>

<h3>8.sed分组</h3>

<p>sed的分组是很好玩的，在替换模式中，“&amp;”代表前面匹配的全部字符串，而反斜杠加数字表示分组。</p>

<pre><code>[jason@localhost ~]$ str="name:jack;age:12"
[jason@localhost ~]$ echo $str | sed -r 's/name:[^;]+/[&amp;]/'
[name:jack];age:12
[jason@localhost ~]$ echo $str | sed -r 's/name:([^;]+)/--\1--/'
--jack--;age:12
</code></pre>

<h3>9.awk常用字符串处理函数</h3>

<pre><code>sub(reg,replacement,string)
gsub(reg,replacement,string)
</code></pre>

<p>将string中匹配正则表达式reg的字符串（全部）替换为replacement</p>

<pre><code>[jason@localhost ~]$ str="name:jack;age:12"
[jason@localhost ~]$ echo $str | awk '{gsub(/a/,"A",$0);print $0}'      
nAme:jAck;Age:12
</code></pre>

<p>&ndash;</p>

<pre><code>index(substring,string) #返回子字符串substring在字符串string中的位置
length(string) #获取字符串的长度
match(string,reg) #获取匹配reg得到的子串在字符串中的位置
split(string,array,separator) #将字符串按分隔符separator分割到array数组中
sprintf("format",expression) #和c语言的sprintf类似
substr(string,position,length)  #获取子字符串
tolower(string)
toupper(string)
</code></pre>

<p>P.S. awk的常见控制语法</p>

<pre><code>exit #退出awk执行
next #跳转到命令块首，并开始下一行数据读入
NF #列数
NR #行号
FS #分隔符
FILENAME #文件名
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[code snippets]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/14/code-snippets/"/>
    <updated>2014-02-14T18:08:28+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/14/code-snippets</id>
    <content type="html"><![CDATA[<h3>ruby文件utf-8编码</h3>

<pre><code># -*- coding: UTF-8 -*-
</code></pre>

<h3>退出ssh登录后继续执行命令</h3>

<p>如果long_run_cmd是一个长时间执行的命令，而我们又想在退出ssh后不至于中断该命令：</p>

<pre><code>nohup long_run_cmd &amp;
</code></pre>

<!-- more -->


<h3>date命令常用操作</h3>

<p><code>bash
date +%Y-%m-%d    #2014-02-21
date -d "1 day ago"  "+%Y-%m-%d %H:%M:%S"  #一天前的当前时间 2014-02-20 11:11:31
date -d "-5 minutes"  "+%Y-%m-%d %H:%M:%S"  #5分钟前
date -d "5 minutes"  "%H:%M:%S"  #5分钟后
date -d "2014-02-20 11:11:31" +%s  #获取某时间的时间戳
date +%s   #返回当前时间戳1392954893
date -d @1392954893 "+%Y-%m-%d %H:%M:%S"  #将时间戳转换为时间
</code></p>
]]></content>
  </entry>
  
</feed>
