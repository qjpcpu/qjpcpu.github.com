<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: blockchain | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2018-01-29T16:16:58+08:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入ethereum源码-p2p模块基础结构]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/"/>
    <updated>2018-01-29T11:19:23+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou</id>
    <content type="html"><![CDATA[<p>(go-ethereum/p2p)包允许您快速方便地将对等网络添加到任何类型的应用程序。p2p包采用模块化结构,包含p2p网络节点通信维护及新节点发现,将网络结构的基础细节封装并向上层屏蔽,并且暴露了简单接口让上层实现子协议,上层应用使用自己的附加子协议扩展p2p非常简单直接.</p>

<p>如果将以太坊的p2p类比做tcp协议,那么p2p暴露出来的子协议就类似http,使得以太坊能够在基础p2p基础上构建出whisper网络。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#peer-to-peer">Peer to peer</a></li>
  <li><a href="#peer">peer接入</a></li>
  <li><a href="#rlp">数据传输格式RLP</a></li>
  <li><a href="#section">参考文献</a></li>
</ul>

<h1 id="peer-to-peer">Peer to peer</h1>

<p>在深入了解前,最好先看看基于p2p包怎么实现一个自己子协议,建立对其的直观印象</p>

<blockquote>
  <p>下面示例来基于官方[Peer to peer]wiki文档(官方文档有个小bug, ^_^),详细参考文献</p>
</blockquote>

<p>启动一个p2p节点仅需要对<code>p2p.Server</code>做一些简单配置:</p>

<p><code>go
nodekey, _ := crypto.GenerateKey()
srv := p2p.Server{
    Config: p2p.Config{
        MaxPeers:   10,
        PrivateKey: nodekey,
        Name:       "my node name",
        ListenAddr: ":30300",
        Protocols:  []p2p.Protocol{},
        NAT:        nat.Any(),   // 支持内网穿透
        Logger:     log.New(),
    },
}
</code></p>

<p>这样启动的节点仅包含了以太坊自身的基础协议:</p>

<p>要实现自己的子协议,就需要拓展<code>Protocols:  []p2p.Protocol{}</code>,实现自己的<code>p2p.Protocol</code></p>

<p><code>go
func MyProtocol() p2p.Protocol {
	return p2p.Protocol{                                                          // 1.
		Name:    "MyProtocol",                                                    // 2.
		Version: 1,                                                               // 3.
		Length:  1,                                                               // 4.
		Run:     func(peer *p2p.Peer, ws p2p.MsgReadWriter) error { return nil }, // 5.
	}
}
</code></p>

<ol>
  <li>一个子协议即一个<code>p2p.Protocol</code></li>
  <li>子协议名,需要唯一标识该子协议</li>
  <li>协议版本号,当一个子协议有多个版本时,采纳最高版本的协议</li>
  <li>这个协议需要依赖的信息数目，因为p2p网络是可扩展的，因此其需要具有能够发送随意个数的信息的能力（需要携带type，在下文中我们能够看到说明），p2p的handler需要知道应该预留多少空间以用来服务你的协议。这是也是共识信息能够通过message ID到达各个peer并实现协商的保障。我们的协议仅仅支持一个message</li>
  <li>在你的协议主要的handler中，我们现在故意将其留空。这个peer变量是指代连接到当前节点，其携带了一些peer本身的信息。其ws变量是reader和writer允许你同该peer进行通信，如果信息能够发送到当前节点，则反之也能够从本节点发送到对端peer节点</li>
</ol>

<p>现在让我们将前面留空的handler代码实现，以让它能够同别的peer通信:</p>

<p>```go
const messageId = 0   // 1.
type Message string   // 2.</p>

<p>func msgHandler(peer *p2p.Peer, ws p2p.MsgReadWriter) error {
    for {
        msg, err := ws.ReadMsg()   // 3.
        if err != nil {            // 4.
            return err // if reading fails return err which will disconnect the peer.
        }</p>

<pre><code>    var myMessage [1]Message
    err = msg.Decode(&amp;myMessage) // 5.
    if err != nil {
        // handle decode error
        continue
    }
    
    switch myMessage[0] {
    case "foo":
        err := p2p.SendItems(ws, messageId, "bar")  // 6.
        if err != nil {
            return err // return (and disconnect) error if writing fails.
        }
     default:
         fmt.Println("recv:", myMessage)
     }
}

return nil } ```
</code></pre>

<ol>
  <li>其中有且唯一的已知信息ID；</li>
  <li>将Messages alias 为string类型；</li>
  <li>ReadMsg将一直阻塞等待，直到其收到了一条新的信息，一个错误或者EOF；</li>
  <li>如果在读取流信息的过程当中收到了一个错误，最好的解决实践是将其返回给p2p server进行处理。这种错误通常是对端节点已经断开连接；</li>
  <li>msg包括两个属性和一个decode方法
    <ol>
      <li>Code 包括了信息ID，Code == messageId (i.e.0)</li>
      <li>Payload 是信息的内容</li>
      <li>Decode(<ptr>) 是一个工具方法：取得 msg.Payload并将其解码，并将其内容设置到传入的message指针中，如果失败了则返回一个error</ptr></li>
    </ol>
  </li>
  <li>如果解码出来的信息是foo将发回一个NewMessage并用messageId标记信息类型，信息内容是bar；而bar信息在被对端收到之后将被defaultcase捕获。</li>
</ol>

<p>现在，我们将上述的所有部分整合起来，得到下面的p2p样例代码:</p>

<p>```go
package main</p>

<p>import (
	“fmt”
	“github.com/ethereum/go-ethereum/crypto”
	“github.com/ethereum/go-ethereum/log”
	“github.com/ethereum/go-ethereum/p2p”
	“github.com/ethereum/go-ethereum/p2p/discover”
	“github.com/ethereum/go-ethereum/p2p/nat”
	“net”
	“os”
)</p>

<p>const messageId = 0</p>

<p>type Message string</p>

<p>func MyProtocol() p2p.Protocol {
	return p2p.Protocol{
		Name:    “MyProtocol”,
		Version: 1,
		Length:  1,
		Run:     msgHandler,
	}
}
func main() {
	nodekey, _ := crypto.GenerateKey()
	logger := log.New()
	logger.SetHandler(log.StderrHandler)
	srv := p2p.Server{
		Config: p2p.Config{
			MaxPeers:   10,
			PrivateKey: nodekey,
			Name:       “my node name”,
			ListenAddr: “:30300”,
			Protocols:  []p2p.Protocol{MyProtocol()},
			NAT:        nat.Any(),
			Logger:     logger,
		},
	}
	if err := srv.Start(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(“started..”, srv.NodeInfo())
	select {}
}</p>

<p>func msgHandler(peer *p2p.Peer, ws p2p.MsgReadWriter) error {
	for {
		msg, err := ws.ReadMsg()
		if err != nil {
			return err
		}</p>

<pre><code>	var myMessage [1]Message
	err = msg.Decode(&amp;myMessage)
	if err != nil {
		// handle decode error
		continue
	}

	fmt.Println("code:", msg.Code, "receiver at:", msg.ReceivedAt, "msg:", myMessage)
	switch myMessage[0] {
	case "foo":
		err := p2p.SendItems(ws, messageId, "bar")
		if err != nil {
			return err
		}
	default:
		fmt.Println("recv:", myMessage)
	}
} } ```
</code></pre>

<h1 id="peer">peer接入</h1>

<p>从上面的例子,我们可以看出来实现ethereum是非常便利的,那么下一步,我们可以看看一个节点是怎么处理新peer的接入的?梳理出这个接入过程,也就明白了节点间基本的数据流通方式.</p>

<p>首先,每个节点启动入口都在<code>func (srv *Server) Start() (err error)</code>.该函数调用<code>srv.startListening()</code>在传入的ip地址监听tcp连接:</p>

<p><code>go
func (srv *Server) startListening() error {
    // Launch the TCP listener.
    listener, err := net.Listen("tcp", srv.ListenAddr)
    ...
    go srv.listenLoop()
    ...
    // 主执行逻辑
    go srv.run(dialer)
    return nil
}
</code></p>

<p>当接收到一个新的tcp连接,节点开始检查并初始化peer</p>

<p><code>go
func (srv *Server) setupConn(c *conn, flags connFlag, dialDest *discover.Node) error {
    ...
    // 从这里开始,其实已经开始了ethereum的自有协议,doEncHandshake是RLPX协议的握手方法
    if c.id, err = c.doEncHandshake(srv.PrivateKey, dialDest); err != nil {
        srv.log.Trace("Failed RLPx handshake", "addr", c.fd.RemoteAddr(), "conn", c.flags, "err", err)
        return err
    }
    ...
    // 两次握手消息代码(handshakeMsg = 0x00)和(discMsg = 0x01)
    phs, err := c.doProtoHandshake(srv.ourHandshake)
    ...
    // 握手完毕,将新连接对象*p2p.conn压入server.addpeer
    err = srv.checkpoint(c, srv.addpeer)
    // If the checks completed successfully, runPeer has now been
    // launched by run.
    return nil
}
</code></p>

<p>下面开始看<code>Start()</code>函数里的节点主逻辑,主逻辑位于<code>Start()</code>末尾的<code>srv.run()</code>,该函数逻辑较复杂,我们现在主要看新peer接入的代码:</p>

<p>```go 
func (srv *Server) run(dialstate dialer) {
      …
      select{
          …
          case c := &lt;-srv.addpeer:  // 在这里取出之前压入addpeer的连接对象conn
          // 执行到这里表明握手完成,并且通过了节点验证
          err := srv.protoHandshakeChecks(peers, c)
          if err == nil {
              // 创建节点peer对象,传入所有子协议实现,自己实现的子协议就是在这里传入peer的
              p := newPeer(c, srv.Protocols)
              …
              go srv.runPeer(p)
          }
          …
      }
      …</p>

<p>}
```</p>

<p>下面继续看最终peer处理逻辑<code>srv.runPeer</code>:</p>

<p>```go
func (p *Peer) run() (remoteRequested bool, err error) {
    …
    // peer逻辑里最重要两个循环逻辑</p>

<pre><code>// 收取消息循环,核心逻辑是根据消息的代号proto, err := p.getProto(msg.Code),
// 取得对应的子协议,然后投放到对应协议的读队列proto.in &lt;- msg
go p.readLoop(readErr)
// 不停发送ping心跳包到远端peer
go p.pingLoop()

// 在startProtocols里最终调用我们自定义子协议的Run方法proto.Run(p, rw)
p.startProtocols(writeStart, writeErr)
... } ```
</code></pre>

<h1 id="rlp">数据传输格式RLP</h1>

<p>以太坊数据传输都是基于RLP编码,下面文字摘自<a href="http://ethfans.org/posts/415">RLP编码原理</a></p>

<blockquote>
  <p>RLP(Recursive Length Prefix，递归长度前缀)是一种编码算法，用于编码任意的嵌套结构的二进制数据，它是以太坊中数据序列化/反序列化的主要方法，区块、交易等数据结构在持久化时会先经过RLP编码后再存储到数据库中</p>
</blockquote>

<p>定义</p>

<blockquote>
  <p>RLP编码的定义只处理两类数据：一类是字符串（例如字节数组），一类是列表。字符串指的是一串二进制数据，列表是一个嵌套递归的结构，里面可以包含字符串和列表，例如<code>["cat",["puppy","cow"],"horse",[[]],"pig",[""],"sheep"]</code>就是一个复杂的列表。其他类型的数据需要转成以上的两类，转换的规则不是RLP编码定义的，可以根据自己的规则转换，例如struct可以转成列表，int可以转成二进制（属于字符串一类），以太坊中整数都以大端形式存储。</p>
</blockquote>

<h1 id="section">参考文献</h1>

<ul>
  <li><a href="https://github.com/ethereum/go-ethereum">go-ethereum github地址</a></li>
  <li><a href="https://github.com/ethereum/go-ethereum/wiki/Peer-to-Peer">Peer to Peer</a></li>
  <li><a href="http://blog.csdn.net/teaspring/article/details/78455046">基于p2p的底层通信</a></li>
  <li><a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-RLP">RLP</a></li>
  <li><a href="http://ethfans.org/posts/415">RLP编码原理</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[p2p之UDP打洞]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/"/>
    <updated>2018-01-26T22:03:15+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong</id>
    <content type="html"><![CDATA[<p>当今互联网到处存在着一些中间件(MIddleBoxes)，如NAT和防火墙，导致两个(不在同一内网)中的客户端无法直接通信。 这些问题即便是到了IPV6时代也会存在，因为即使不需要NAT，但还有其他中间件如防火墙阻挡了链接的建立。 目前部署的中间件多都是在C/S架构上设计的，其中相对隐匿的客户机主动向周知的服务端(拥有静态IP地址和DNS名称)发起链接请求。 大多数中间件实现了一种非对称的通讯模型，即内网中的主机可以初始化对外的链接，而外网的主机却不能初始化对内网的链接， 除非经过中间件管理员特殊配置。</p>

<p>在中间件为常见的NAPT的情况下（也是本文主要讨论的），内网中的客户端没有单独的公网IP地址， 而是通过NAPT转换，和其他同一内网用户共享一个公网IP。这种内网主机隐藏在中间件后的不可访问性对于一些客户端软件如浏览器来说 并不是一个问题，因为其只需要初始化对外的链接，从某方面来看反而还对隐私保护有好处。然而在P2P应用中， 内网主机（客户端）需要对另外的终端（Peer）直接建立链接，但是发起者和响应者可能在不同的中间件后面， 两者都没有公网IP地址。而外部对NAT公网IP和端口主动的链接或数据都会因内网未请求被丢弃掉。本文讨论的就是如何跨越NAT实现内网主机直接通讯的问题。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">网络模型</a></li>
  <li><a href="#section-1">打洞流程</a></li>
  <li><a href="#section-2">先决条件</a></li>
  <li><a href="#section-3">源码示例</a></li>
  <li><a href="#udptcp">udp打洞转tcp通信</a></li>
  <li><a href="#section-4">参考文献</a></li>
</ul>

<h1 id="section">网络模型</h1>

<p>假设客户端A和客户端B的地址都是内网地址，且在不同的NAT后面。A、B上运行的P2P应用程序和服务器S都使用了UDP端口9982，A和B分别初始化了 与Server的UDP通信，地址映射如图所示:</p>

<p><code>
                            Server S
                        207.148.70.129:9981
                               |
                               |
        +----------------------|----------------------+
        |                                             |
      NAT A                                         NAT B
120.27.209.161:6000                            120.26.10.118:3000
        |                                             |
        |                                             |
     Client A                                      Client B
  10.0.0.1:9982                                 192.168.0.1:9982
</code></p>

<p>现在假设客户端A打算与客户端B直接建立一个UDP通信会话。如果A直接给B的公网地址120.26.10.118:3000发送UDP数据，NAT B将很可能会无视进入的 数据（除非是Full Cone NAT），因为源地址和端口与S不匹配，而最初只与S建立过会话。B往A直接发信息也类似。</p>

<p>假设A开始给B的公网地址发送UDP数据的同时，给服务器S发送一个中继请求，要求B开始给A的公网地址发送UDP信息。A往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话，B往A亦然。一旦新的UDP会话在两个方向都打开之后，客户端A和客户端B就能直接通讯， 而无须再通过引导服务器S了。</p>

<p>UDP打洞技术有许多有用的性质。一旦一个的P2P链接建立，链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞， 极大减少了服务器的负载。应用程序不需要知道中间件具体是什么（如果有的话），因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路。</p>

<h1 id="section-1">打洞流程</h1>

<p>假设A现在希望建立一条到B的udp会话，那么这个建立基本流程是:</p>

<p><code>
1. A,B分别建立到Server S的udp会话,那么Server S此时是知道A,B各自的外网ip+端口
2. Server S在和B的udp会话里告诉A的地址(外网ip+端口: 120.27.209.161:6000),同理把B的地址(120.26.10.118:3000)告诉A
3. B向A地址(120.27.209.161:6000)发送一个"握手"udp包,打通A-&gt;B的udp链路
4. 此时A可以向B(120.26.10.118:3000)发送udp包,A-&gt;B的会话建立成功
</code></p>

<h1 id="section-2">先决条件</h1>

<p>能够完成打洞有几个先决条件:</p>

<p><code>
1. A,B所在的nat网络类型(Full cone, Restricted cone, Port-restricted cone, Symmetric NAT)
2. 在一次udp会话期间,nat设备(路由器)会保持内网进程 inner_ip:inner_port &lt;-&gt; share_public_ip:share_port的映射关系,一般根据具体路由器实现,这个映射关系可以维持几分钟到几个小时不等
3. 流程中第3步,nat A收到这个握手包后并不会转发给A,因为它发现自己的没有保存过B的地址,认为这是一个来历不明的包而直接丢弃,然而这个包的作用在于在nat B留下了A的记录,使得nat B认为A是可达或者说可通过了,这样当A-&gt;B再发送udp包时就可以真正到达B了。所以这个"握手"包的作用是可以打通A-&gt;B的通路,是必要的
</code></p>

<h1 id="section-3">源码示例</h1>

<p>使用三台设备模拟,外网设备207.148.70.129模拟Server S,执行server.go代码:</p>

<p>```go server.go 
package main</p>

<p>import (
	“fmt”
	“log”
	“net”
	“time”
)</p>

<p>func main() {
	listener, err := net.ListenUDP(“udp”, &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	log.Printf(“本地地址: &lt;%s&gt; \n”, listener.LocalAddr().String())
	peers := make([]net.UDPAddr, 0, 2)
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf(“error during read: %s”, err)
		}
		log.Printf(“&lt;%s&gt; %s\n”, remoteAddr.String(), data[:n])
		peers = append(peers, *remoteAddr)
		if len(peers) == 2 {</p>

<pre><code>		log.Printf("进行UDP打洞,建立 %s &lt;--&gt; %s 的连接\n", peers[0].String(), peers[1].String())
		listener.WriteToUDP([]byte(peers[1].String()), &amp;peers[0])
		listener.WriteToUDP([]byte(peers[0].String()), &amp;peers[1])
		time.Sleep(time.Second * 8)
		log.Println("中转服务器退出,仍不影响peers间通信")
		return
	}
} } ```
</code></pre>

<p>另外两台分别位于不同内网后的设备,均运行相同代码peer.go:</p>

<p>```go peer.go
package main</p>

<p>import (
	“fmt”
	“log”
	“net”
	“os”
	“strconv”
	“strings”
	“time”
)</p>

<p>var tag string</p>

<p>const HAND_SHAKE_MSG = “我是打洞消息”</p>

<p>func main() {
	// 当前进程标记字符串,便于显示
	tag = os.Args[1]
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9982} // 注意端口必须固定
	dstAddr := &amp;net.UDPAddr{IP: net.ParseIP(“207.148.70.129”), Port: 9981}
	conn, err := net.DialUDP(“udp”, srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	if _, err = conn.Write([]byte(“hello, I’m new peer:” + tag)); err != nil {
		log.Panic(err)
	}
	data := make([]byte, 1024)
	n, remoteAddr, err := conn.ReadFromUDP(data)
	if err != nil {
		fmt.Printf(“error during read: %s”, err)
	}
	conn.Close()
	anotherPeer := parseAddr(string(data[:n]))
	fmt.Printf(“local:%s server:%s another:%s\n”, srcAddr, remoteAddr, anotherPeer.String())</p>

<pre><code>// 开始打洞
bidirectionHole(srcAddr, &amp;anotherPeer)
</code></pre>

<p>}</p>

<p>func parseAddr(addr string) net.UDPAddr {
	t := strings.Split(addr, “:”)
	port, _ := strconv.Atoi(t[1])
	return net.UDPAddr{
		IP:   net.ParseIP(t[0]),
		Port: port,
	}
}</p>

<p>func bidirectionHole(srcAddr *net.UDPAddr, anotherAddr *net.UDPAddr) {
	conn, err := net.DialUDP(“udp”, srcAddr, anotherAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	// 向另一个peer发送一条udp消息(对方peer的nat设备会丢弃该消息,非法来源),用意是在自身的nat设备打开一条可进入的通道,这样对方peer就可以发过来udp消息
	if _, err = conn.Write([]byte(HAND_SHAKE_MSG)); err != nil {
		log.Println(“send handshake:”, err)
	}
	go func() {
		for {
			time.Sleep(10 * time.Second)
			if _, err = conn.Write([]byte(“from [” + tag + “]”)); err != nil {
				log.Println(“send msg fail”, err)
			}
		}
	}()
	for {
		data := make([]byte, 1024)
		n, _, err := conn.ReadFromUDP(data)
		if err != nil {
			log.Printf(“error during read: %s\n”, err)
		} else {
			log.Printf(“收到数据:%s\n”, data[:n])
		}
	}
}
```</p>

<p>注意代码仅模拟打洞基础流程,如果读者测试网络情况较差发生udp丢包,可能看不到预期结果,此时简单重启server,peer即可.</p>

<p>完整代码参考<a href="https://github.com/qjpcpu/p2pbyudp">github</a></p>

<h1 id="udptcp">udp打洞转tcp通信</h1>

<p>通常,由于udp打洞实现简单,p2p的实现采用udp打洞较多,然而当通路建立起来后使用tcp进行节点间通信可以获取更好的通信效果。因为udp打洞完成后形成的nat映射是和tcp/udp无关的,所以此时可以转为使用tcp建立连接,达到最终的p2p的tcp通信.由于代码较简单,这里就不给出示例了。</p>

<h1 id="section-4">参考文献</h1>

<ul>
  <li><a href="https://yq.aliyun.com/articles/227421">UDP用打洞技术穿透NAT的原理与实现</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/26796476">P2P通信原理与实现</a></li>
  <li><a href="https://github.com/jtriley/pystun">NAT类型检测工具</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
