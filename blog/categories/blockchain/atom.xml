<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: blockchain | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2018-02-07T23:47:46+08:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入ethereum源码-whisper协议解读]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/02/07/shen-ru-ethereumyuan-ma-whisperxie-yi-jie-du/"/>
    <updated>2018-02-07T16:13:02+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/02/07/shen-ru-ethereumyuan-ma-whisperxie-yi-jie-du</id>
    <content type="html"><![CDATA[<p>whisper协议是以太坊DApps之间的通信协议。</p>

<!-- more -->

<h1 id="section">概述</h1>

<p>whisper是完全基于<code>ID</code>的消息系统,它的设计目的是形成一套p2p节点间的异步广播系统。whisper网络上的消息是加密传送的,完全可以暴露在公网进行传输;此外,为了防范<code>DDos</code>攻击,whisper使用了<code>proof-of-work(PoW)</code>工作量证明提高消息发送门槛。</p>

<h1 id="whisper">whisper基础构件</h1>

<p>whisper协议对上层暴露出一套类似于<code>订阅-发布</code>的API模型,节点可以申请自己感兴趣的<code>topic</code>，那么就只会接收到这些<code>topic</code>的消息,无关主题的消息将被丢弃。在这套体系内，有几个基础构件需要说明下:</p>

<h2 id="envelope">Envelope信封</h2>

<p><code>envelope即信封</code>是whisper网络节点传输数据的基本形式。信封包含了加密的数据体和明文的元数据,元数据主要用于基本的消息校验和消息体的解密。</p>

<p>信封是以RLP编码的格式传输:</p>

<p><code>
[ Version, Expiry, TTL, Topic, AESNonce, Data, EnvNonce ]
</code></p>

<ul>
  <li><code>Version</code>:最多4字节(目前仅使用了1字节)，如果信封的<code>Version</code>比本节点当前值高,将无法解密,仅做转发</li>
  <li><code>Expiry</code>:4字节（unix时间戳秒数）,过期时间</li>
  <li><code>TTL</code>:4字节,剩余存活时间秒数</li>
  <li><code>Topic</code>:4字节,信封主题</li>
  <li><code>AESNonce</code>:12字节随机数据,仅在对称加密时有效</li>
  <li><code>Data</code>:消息体</li>
  <li><code>EnvNonce</code>:8字节任意数据(用于PoW计算)</li>
</ul>

<p>如果节点无法解密信封，那么节点对信封内的消息内容一无所知，单这并不影响节点将消息进行转发扩散。</p>

<h2 id="message">Message消息</h2>

<p>信封内的消息体解密后即得到消息内容。</p>

<h2 id="topic">Topic主题</h2>

<p>每个信封上都有一个主题,注意主题可以仅使用部分前缀</p>

<h2 id="filter">Filter过滤器</h2>

<p><code>filter</code>即<code>订阅-发布</code>模型中的订阅者</p>

<h2 id="pow">PoW工作量证明</h2>

<p><code>PoW</code>的存在是为了反垃圾信息以及降低网络负担。计算PoW所付出的代价可以理解为抵扣节点为传播和存储信息锁花费的资源.</p>

<p>在<code>whisperv5</code>中,<code>PoW</code>定义为:</p>

<p><code>
PoW = (2^BestBit) / (size * TTL)
</code></p>

<ul>
  <li><code>BestBit</code>是hash计算值的前导0个数</li>
  <li><code>size</code>是消息大小</li>
  <li><code>TTL</code></li>
</ul>

<p>具有高<code>PoW</code>的消息具有优先处理权。</p>

<h1 id="section-1">通信流程</h1>

<p>whisper协议的实现位于包<code>github.com/ethereum/go-ethereum/whisper</code>，该包下面有多个版本实现,目前最新协议包是<code>whisperv6</code>.</p>

<h2 id="whisper-main-loop">whisper main loop</h2>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/whisper-main-loop.png" alt="whisper-main-loop" /></p>

<p>whisper节点启动后产生两个分支:</p>

<ul>
  <li>一个分支负责清理<code>shh.envelopes</code>中的过期消息</li>
  <li>另一个分支(proccessQueue)从两个队列取出新接收到的消息,根据消息对应topic投放(Trigger)到对应接收者(filter),从而交付给上层应用进行处理</li>
</ul>

<p>补充说下whisper里两个队列<code>messageQueue,p2pMsgQueue</code>的不同作用,<code>messageQueue</code>接收普通的广播消息,<code>p2pMsgQueue</code>接收点对点的直接消息,可绕过<code>pow</code>和<code>ttl</code>限制.</p>

<h2 id="whisper-protocol">whisper protocol</h2>

<p>whisper协议的具体实现里,代码流程也非常清晰:</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/whisper-peer-loop.png" alt="whisper-peer-loop" /></p>

<p>每个peer连接成功后,产生两个goroutine,进行消息接收和广播:</p>

<ul>
  <li>接收消息协程不断从连接中读取新消息,并且将消息暂存到<code>shh.envelopes</code>中,如果发现是一条未接收过的新消息,则将消息转发到对应的队列<code>(messageQueue,p2pMsgQueue)</code></li>
  <li>广播协程负责将该peer未接收过的消息(本节点认为该peer未接收过,并非peer一定没接收过,p2p网络其他节点可能已经将消息广播到该节点了)投递到该peer</li>
</ul>

<h1 id="section-2">消息收发</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ethereum源码-p2p模块节点发现机制]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/01/30/shen-ru-ethereumyuan-ma-p2pmo-kuai-jie-dian-fa-xian-ji-zhi/"/>
    <updated>2018-01-30T11:40:37+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/01/30/shen-ru-ethereumyuan-ma-p2pmo-kuai-jie-dian-fa-xian-ji-zhi</id>
    <content type="html"><![CDATA[<p>ethereum是基于kademlia协议实现其节点自动发现机制,完整整个网络拓扑关系的构建刷新。
<!-- more --></p>

<ul id="markdown-toc">
  <li><a href="#kademlia">Kademlia协议</a></li>
  <li><a href="#kademlia-like">以太坊Kademlia-like协议</a></li>
  <li><a href="#section">源码跟踪以太坊节点发现机制</a>    <ul>
      <li><a href="#refreshloop">1. <code>refreshLoop()</code></a></li>
      <li><a href="#loopreadloop">2. <code>loop()</code>和<code>readLoop()</code></a></li>
    </ul>
  </li>
  <li><a href="#section-1">内网穿透</a></li>
  <li><a href="#section-2">参考文献</a></li>
</ul>

<h1 id="kademlia">Kademlia协议</h1>

<blockquote>
  <p>以下内容摘自维基百科,全文查看参考文献Kademlia</p>
</blockquote>

<p>Kademlia是一种通过分散式杂凑表实现的协议算法，它是由Petar和David为非集中式P2P计算机网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。Kademlia网络节点之间使用UDP进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位。</p>

<p>Kademlia路由表由多个列表组成，每个列表对应节点ID的一位（例如：假如节点ID共有128位，则节点的路由表将包含128个列表），包含多个条目，条目中包含定位其他节点所必要的一些数据。列表条目中的这些数据通常是由其他节点的IP地址，端口和节点ID组成。每个列表对应于与节点相距特定范围距离的一些节点，节点的第n个列表中所找到的节点的第n位与该节点的第n位肯定不同，而前n-1位相同，这就意味着很容易使用网络中远离该节点的一半节点来填充第一个列表（第一位不同的节点最多有一半），而用网络中四分之一的节点来填充第二个列表（比第一个列表中的那些节点离该节点更近一位），依次类推。如果ID有128个二进制位，则网络中的每个节点按照不同的异或距离把其他所有的节点分成了128类，ID的每一位对应于其中的一类。随着网络中的节点被某节点发现，它们被逐步加入到该节点的相应的列表中，这个过程中包括向节点列表中存信息和从节点列表中取信息的操作，甚至还包括当时协助其他节点寻找相应键对应值的操作。这个过程中发现的所有节点都将被加入到节点的列表之中，因此节点对整个网络的感知是动态的，这使得网络一直保持着频繁地更新，增强了抵御错误和攻击的能力。</p>

<p>在Kademlia相关的论文中，列表也称为K桶，其中K是一个系统变量，如20，每一个K桶是一个最多包含K个条目的列表，也就是说，网络中所有节点的一个列表（对应于某一位，与该节点相距一个特定的距离）最多包含20个节点。随着对应的bit位变低（即对应的异或距离越来越短），K桶包含的可能节点数迅速下降（这是由于K桶对应的异或距离越近，节点数越少），因此，对应于更低bit位的K桶显然包含网络中所有相关部分的节点。由于网络中节点的实际数量远远小于可能ID号的数量，所以对应那些短距离的某些K桶可能一直是空的（如果异或距离只有1，可能的数量就最大只能为1，这个异或距离为1的节点如果没有发现，则对应于异或距离为1的K桶则是空的）。</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/63/Dht_example_SVG.svg" alt="kademlia example" /></p>

<p>让我们看上面的那个简单网络，该网络最大可有2^3，即8个关键字和节点，目前共有7个节点加入，每个节点用一个小圈表示（在树的底部）。我们考虑那个用黑圈标注的节点6，它共有3个K桶，节点0，1和2（二进制表示为000，001和010）是第一个K桶的候选节点，节点3目前（二进制表示为011）还没有加入网络，节点4和节点5（二进制表示分别为100和101）是第二个K桶的候选节点，只有节点7（二进制表示为111）是第3个K桶的候选节点。图中，3个K桶都用灰色圈表示，假如K桶的大小（即K值）是2，那么第一个K桶只能包含3个节点中的2个。众所周知，那些长时间在线连接的节点未来长时间在线的可能性更大，基于这种静态统计分布的规律，Kademlia选择把那些长时间在线的节点存入K桶，这一方法增长了未来某一时刻有效节点的数量，同时也提供了更为稳定的网络。当某个K桶已满，而又发现了相应于该桶的新节点的时候，那么，就首先检查K桶中最早访问的节点，假如该节点仍然存活，那么新节点就被安排到一个附属列表中（作为一个替代缓存）.只有当K桶中的某个节点停止响应的时候，替代cache才被使用。换句话说，新发现的节点只有在老的节点消失后才被使用。</p>

<h1 id="kademlia-like">以太坊Kademlia-like协议</h1>

<p>以太坊的kademlia网(简称kad)和标准kad网有部分差异.</p>

<p>下面对照以太坊源码,阐述下kad网里几个概念:</p>

<p><code>go github.com/ethereum/go-ethereum/p2p/discover/table.go
const (
    alpha      = 3                      // Kademlia并发参数
    bucketSize = 16                     // Kademlia K桶大小(可容纳节点数)
    hashBits   = len(common.Hash{}) * 8 // 每个节点ID长度,32*8=256, 32位16进制
    nBuckets   = hashBits + 1           // K桶个数
)
</code></p>

<ul>
  <li><code>α</code>即代码里的<code>alpha</code>,是系统内一个优化参数,控制每次从K桶最多取出节点个数,ethereum取值3</li>
  <li><code>bucketSize</code>,K桶大小,ethereum取16</li>
  <li><code>hashBits</code>,节点长度256位</li>
  <li><code>nBuckets</code>,K桶个数,目前取257</li>
</ul>

<p>以太坊Kad网总共定义了4种消息类型:</p>

<p>```go github.com/ethereum/go-ethereum/p2p/discover/udp.go
const (
    pingPacket = iota + 1 // ping操作
    pongPacket            // pong操作</p>

<pre><code>findnodePacket        // find node节点查询
neighborsPacket       // neighbors邻居回应 ) ```
</code></pre>

<p><code>ping</code>和<code>pong</code>是一对操作,用于检测节点活性,节点收到<code>ping</code>消息后立即回复<code>pong</code>响应:</p>

<p><code>go
// 收到ping消息的响应函数
func (req *ping) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {
    ...
    // 向ping消息发送方回复pong
    t.send(from, pongPacket, &amp;pong{
        To:         makeEndpoint(from, req.From.TCP),
        ReplyTok:   mac,
        Expiration: uint64(time.Now().Add(expiration).Unix()),
    })
    if !t.handleReply(fromID, pingPacket, req) {
        // 成功完成一次ping-pong,更新K桶节点信息
        go t.bond(true, fromID, from, req.From.TCP)
    }
    return nil
}
</code></p>

<p><code>findnode</code>和<code>neighbors</code>是一对操作.</p>

<p><code>findnode</code>用于查找与某节点相距最近的节点,查找到后以<code>neighbors</code>类型消息回复查找发起者</p>

<p>```go
// 收到findnode消息的响应函数
func (req *findnode) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {
    …
    target := crypto.Keccak256Hash(req.Target[:])
    …
    // 从本节点路由表里查找于target节点相距最近的bucketSize的节点
    closest := t.closest(target, bucketSize).entries
    …</p>

<pre><code>p := neighbors{Expiration: uint64(time.Now().Add(expiration).Unix())}
// 回复查询发起方
for i, n := range closest {
    ...
    t.send(from, neighborsPacket, &amp;p)
    ...
}
return nil } ```
</code></pre>

<h1 id="section">源码跟踪以太坊节点发现机制</h1>

<p>了解了以太坊的4种基本操作以及kad网络概念,我们就可以来看看节点发现机制怎么流转起来的:</p>

<p>节点发现的代码位于<code>github.com/ethereum/go-ethereum/p2p/discover</code>包。</p>

<p>首先,在节点启动时启动UDP”端口监听”:<code>server.Start() ==&gt; discover.ListenUDP ==&gt; newUDP()</code></p>

<p><code>newUDP()</code>分叉出去三个流程,三个流程均是无限循环:</p>

<ul>
  <li><code>func (tab *Table) refreshLoop()</code></li>
  <li><code>func (t *udp) loop()</code></li>
  <li><code>func (t *udp) readLoop(unhandled chan ReadPacket)</code></li>
</ul>

<h4 id="refreshloop">1. <code>refreshLoop()</code></h4>

<p>该流程每隔1小时或按需刷新K桶,核心逻辑实现位于<code>doRefresh</code>函数:</p>

<p>```go github.com/ethereum/go-ethereum/p2p/discover/table.go
func (tab *Table) doRefresh(done chan struct{}) {
    …
    // 和标准Kademlia协议选取最旧的K桶进行刷新不同，以太坊选取一个随机节点ID作为刷新基点
    var target NodeID
    rand.Read(target[:])
    // lookup函数是最kad网最核心函数,查询离target最近一批节点
    result := tab.lookup(target, false)
    if len(result) &gt; 0 {
        return
    }</p>

<pre><code>// 如果没找到,则从本地节点数据库加载预配置的种子节点到对应K桶
seeds := tab.db.querySeeds(seedCount, seedMaxAge)
seeds = tab.bondall(append(seeds, tab.nursery...))
...
// 最后,以自身作为目标节点,刷新K桶
tab.lookup(tab.self.ID, false) } ```
</code></pre>

<p><code>tab.lookup</code>函数虽然关键,然而其逻辑其实是很简单的:</p>

<p>a. 查询离target最近一批节点,距离计算即对kad网络XOR(异或)距离计算的实现</p>

<p><code>go
func (tab *Table) closest(target common.Hash, nresults int) *nodesByDistance {
    // 遍历本地路由节点表
    close := &amp;nodesByDistance{target: target}
    for _, b := range tab.buckets {
        for _, n := range b.entries {
            close.push(n, nresults)
        }
    }
    return close
}
// close.push最终调用distcmp进行异或计算
func distcmp(target, a, b common.Hash) int {
    for i := range target {
        da := a[i] ^ target[i]
        db := b[i] ^ target[i]
        if da &gt; db {
            return 1
        } else if da &lt; db {
            return -1
        }
    }
    return 0
}
</code></p>

<p>b. 迭代上一步查到的所有节点,向这些节点发起<code>findnode</code>操作查询离target节点最近的节点列表,将查询得到的节点进行<code>ping-pong</code>测试,将测试通过的节点落库保存</p>

<p>经过这个流程后,节点的K桶就能够比较均匀地将不同网络节点更新到本地K桶中。</p>

<h4 id="loopreadloop">2. <code>loop()</code>和<code>readLoop()</code></h4>

<p>这两个循环流程放在一起说,它们主要是一个工程实现,将异步调用代码通过channel串接成同步。业务上主要是负责处理<code>ping,pong,findnode,neighbors</code>四个消息类型的收发。</p>

<p>唯一值得稍加阐述的可能只有<code>pending</code>结构:</p>

<p>```go
// pending实现了一种延迟处理逻辑
//
// 它主要有两个作用:
// 1. 提供回调机制,当某一个操作发起异步请求时,就使用pending结构封装一个闭包,当收到异步回复后从pending列表取出这个闭包,执行回调,因此在这个回调里可以完成数据包校验等后处理
// 如findnode操作将更新k桶的操作暂存,再获取到异步回复后执行这个闭包完成k桶更新
// 2. 提供多个回复接收功能,一个RPC请求可能会对应多个回复包,比如findnode对应多个neigbours回复包,此时可以提供多个pending进行逐个包校验
type pending struct {
    // 来源节点
    from  NodeID
    ptype byte</p>

<pre><code>// 调用超时丢弃pending结构
deadline time.Time

// 回调函数,简单而强大
callback func(resp interface{}) (done bool)

errc chan&lt;- error } ```
</code></pre>

<p>综述,邻居节点发现流程:</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth_kad.jpeg" alt="kademlia" /></p>

<p>节点第一次启动读取公共种子节点信息,已本节点ID作为target更新本地K桶,然后每隔一段时间进行节点更新, 刷新K桶流程如下:</p>

<p>a. 随机生成目标节点Id，记为TargetId，从1开始记录发现次数和刷新时间。</p>

<p>b. 在当前节点的K桶里查找与目标节点最近的16个节点</p>

<p>c. 向b中得到的每个节点发送findnode命令,接收到每个节点传回的neighbours节点</p>

<p>d. 对c返回的每个节点进行ping-pong测试然后更新到本地k桶</p>

<h1 id="section-1">内网穿透</h1>

<p>ethereum是基于p2p通信的,所有的操作都有可能涉及到内网穿透,而目前内网穿透最常用的方法是udp打洞,这也是kad网络使用udp作为基础通信协议的原因。</p>

<p>一个简单的udp打通进行p2p通信的例子讲解可以参考<a href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/">深入ethereum源码-p2p模块基础结构</a>。</p>

<p>然而以太坊里将这部分逻辑全部隐藏,可以在节点初始化函数里看出一点痕迹:</p>

<p><code>go 
func (srv *Server) Start() (err error) {
        addr, err := net.ResolveUDPAddr("udp", srv.ListenAddr)
        if err != nil {
            return err
        }
        conn, err = net.ListenUDP("udp", addr)
        if err != nil {
            return err
        }
        realaddr = conn.LocalAddr().(*net.UDPAddr)
        if srv.NAT != nil {
            if !realaddr.IP.IsLoopback() {
                // 进行内网网端口映射
                go nat.Map(srv.NAT, srv.quit, "udp", realaddr.Port, realaddr.Port, "ethereum discovery")
            }
            // TODO: react to external IP changes over time.
            if ext, err := srv.NAT.ExternalIP(); err == nil {
                realaddr = &amp;net.UDPAddr{IP: ext, Port: realaddr.Port}
            }
        }
}
</code></p>

<p>首先，以太坊tcp/udp共用了一个端口,然后使用uPnp协议簇进行内外网端口映射,完成链路打通,从而穿透内网.</p>

<p>具体封装位于<code>nat</code>模块,但具体实现也是使用了三方库<a href="https://github.com/huin/goupnp">goupnp</a>.具体实现是关于uPnP的一个大话题,就不在这里分叉出去了。</p>

<h1 id="section-2">参考文献</h1>

<ul>
  <li><a href="https://zh.wikipedia.org/wiki/Kademlia">Kademlia</a></li>
  <li><a href="http://www.yeolar.com/note/2010/03/21/kademlia/">Kademlia协议原理简介</a></li>
  <li><a href="https://github.com/ethereum/wiki/wiki/Node-discovery-protocol">Node discovery protocol</a></li>
  <li><a href="http://www.8btc.com/etc-p2p">P2P网络及节点发现机制</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ethereum源码-p2p模块基础结构]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/"/>
    <updated>2018-01-29T11:19:23+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou</id>
    <content type="html"><![CDATA[<p>(go-ethereum/p2p)包允许您快速方便地将对等网络添加到任何类型的应用程序。p2p包采用模块化结构,包含p2p网络节点通信维护及新节点发现,将网络结构的基础细节封装并向上层屏蔽,并且暴露了简单接口让上层实现子协议,上层应用使用自己的附加子协议扩展p2p非常简单直接.</p>

<p>如果将以太坊的p2p类比做tcp协议,那么p2p暴露出来的子协议就类似http,使得以太坊能够在基础p2p基础上构建出whisper网络。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#peer-to-peer">Peer to peer</a></li>
  <li><a href="#peer">peer接入</a></li>
  <li><a href="#rlp">数据传输格式RLP</a></li>
  <li><a href="#section">总述</a></li>
  <li><a href="#section-1">参考文献</a></li>
</ul>

<h1 id="peer-to-peer">Peer to peer</h1>

<p>在深入了解前,最好先看看基于p2p包怎么实现一个自己子协议,建立对其的直观印象</p>

<blockquote>
  <p>下面示例来基于官方[Peer to peer]wiki文档(官方文档有个小bug, ^_^),详细参考文献</p>
</blockquote>

<p>启动一个p2p节点仅需要对<code>p2p.Server</code>做一些简单配置:</p>

<p><code>go
nodekey, _ := crypto.GenerateKey()
srv := p2p.Server{
    Config: p2p.Config{
        MaxPeers:   10,
        PrivateKey: nodekey,
        Name:       "my node name",
        ListenAddr: ":30300",
        Protocols:  []p2p.Protocol{},
        NAT:        nat.Any(),   // 支持内网穿透
        Logger:     log.New(),
    },
}
</code></p>

<p>这样启动的节点仅包含了以太坊自身的基础协议:</p>

<p>要实现自己的子协议,就需要拓展<code>Protocols:  []p2p.Protocol{}</code>,实现自己的<code>p2p.Protocol</code></p>

<p><code>go
func MyProtocol() p2p.Protocol {
	return p2p.Protocol{                                                          // 1.
		Name:    "MyProtocol",                                                    // 2.
		Version: 1,                                                               // 3.
		Length:  1,                                                               // 4.
		Run:     func(peer *p2p.Peer, ws p2p.MsgReadWriter) error { return nil }, // 5.
	}
}
</code></p>

<ol>
  <li>一个子协议即一个<code>p2p.Protocol</code></li>
  <li>子协议名,需要唯一标识该子协议</li>
  <li>协议版本号,当一个子协议有多个版本时,采纳最高版本的协议</li>
  <li>该协议拥有的消息类型个数,因为p2p网络是可扩展的，因此其需要具有能够发送随意个数的信息的能力（需要携带type，在下文中我们能够看到说明）,p2p的handler需要知道应该预留多少空间以用来服务你的协议。这是也是共识信息能够通过message ID到达各个peer并实现协商的保障。我们的协议仅仅支持一种类型</li>
  <li>在你的协议主要的handler中，我们现在故意将其留空。这个peer变量是指代连接到当前节点，其携带了一些peer本身的信息。其ws变量是reader和writer允许你同该peer进行通信，如果信息能够发送到当前节点，则反之也能够从本节点发送到对端peer节点</li>
</ol>

<p>现在让我们将前面留空的handler代码实现，以让它能够同别的peer通信:</p>

<p>```go
const messageId = 0   // 1.
type Message string   // 2.</p>

<p>func msgHandler(peer *p2p.Peer, ws p2p.MsgReadWriter) error {
    for {
        msg, err := ws.ReadMsg()   // 3.
        if err != nil {            // 4.
            return err // if reading fails return err which will disconnect the peer.
        }</p>

<pre><code>    var myMessage [1]Message
    err = msg.Decode(&amp;myMessage) // 5.
    if err != nil {
        // handle decode error
        continue
    }
    
    switch myMessage[0] {
    case "foo":
        err := p2p.SendItems(ws, messageId, "bar")  // 6.
        if err != nil {
            return err // return (and disconnect) error if writing fails.
        }
     default:
         fmt.Println("recv:", myMessage)
     }
}

return nil } ```
</code></pre>

<ol>
  <li>其中有且唯一的已知信息ID；</li>
  <li>将Messages alias 为string类型；</li>
  <li>ReadMsg将一直阻塞等待，直到其收到了一条新的信息，一个错误或者EOF；</li>
  <li>如果在读取流信息的过程当中收到了一个错误，最好的解决实践是将其返回给p2p server进行处理。这种错误通常是对端节点已经断开连接；</li>
  <li>msg包括两个属性和一个decode方法
    <ol>
      <li>Code 包括了信息ID，Code == messageId (i.e.0)</li>
      <li>Payload 是信息的内容</li>
      <li>Decode(<ptr>) 是一个工具方法：取得 msg.Payload并将其解码，并将其内容设置到传入的message指针中，如果失败了则返回一个error</ptr></li>
    </ol>
  </li>
  <li>如果解码出来的信息是foo将发回一个NewMessage并用messageId标记信息类型，信息内容是bar；而bar信息在被对端收到之后将被defaultcase捕获。</li>
</ol>

<p>现在，我们将上述的所有部分整合起来，得到下面的p2p样例代码:</p>

<p>```go
package main</p>

<p>import (
	“fmt”
	“github.com/ethereum/go-ethereum/crypto”
	“github.com/ethereum/go-ethereum/log”
	“github.com/ethereum/go-ethereum/p2p”
	“github.com/ethereum/go-ethereum/p2p/discover”
	“github.com/ethereum/go-ethereum/p2p/nat”
	“net”
	“os”
)</p>

<p>const messageId = 0</p>

<p>type Message string</p>

<p>func MyProtocol() p2p.Protocol {
	return p2p.Protocol{
		Name:    “MyProtocol”,
		Version: 1,
		Length:  1,
		Run:     msgHandler,
	}
}
func main() {
	nodekey, _ := crypto.GenerateKey()
	logger := log.New()
	logger.SetHandler(log.StderrHandler)
	srv := p2p.Server{
		Config: p2p.Config{
			MaxPeers:   10,
			PrivateKey: nodekey,
			Name:       “my node name”,
			ListenAddr: “:30300”,
			Protocols:  []p2p.Protocol{MyProtocol()},
			NAT:        nat.Any(),
			Logger:     logger,
		},
	}
	if err := srv.Start(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(“started..”, srv.NodeInfo())
	select {}
}</p>

<p>func msgHandler(peer *p2p.Peer, ws p2p.MsgReadWriter) error {
	for {
		msg, err := ws.ReadMsg()
		if err != nil {
			return err
		}</p>

<pre><code>	var myMessage [1]Message
	err = msg.Decode(&amp;myMessage)
	if err != nil {
		// handle decode error
		continue
	}

	fmt.Println("code:", msg.Code, "receiver at:", msg.ReceivedAt, "msg:", myMessage)
	switch myMessage[0] {
	case "foo":
		err := p2p.SendItems(ws, messageId, "bar")
		if err != nil {
			return err
		}
	default:
		fmt.Println("recv:", myMessage)
	}
} } ```
</code></pre>

<h1 id="peer">peer接入</h1>

<p>从上面的例子,我们可以看出来实现ethereum是非常便利的,那么下一步,我们可以看看一个节点是怎么处理新peer的接入的?梳理出这个接入过程,也就明白了节点间基本的数据流通方式.</p>

<p>首先,每个节点启动入口都在<code>func (srv *Server) Start() (err error)</code>.该函数调用<code>srv.startListening()</code>在传入的ip地址监听tcp连接:</p>

<p><code>go
func (srv *Server) startListening() error {
    // Launch the TCP listener.
    listener, err := net.Listen("tcp", srv.ListenAddr)
    ...
    go srv.listenLoop()
    ...
    // 主执行逻辑
    go srv.run(dialer)
    return nil
}
</code></p>

<p>当接收到一个新的tcp连接,节点开始检查并初始化peer</p>

<p><code>go
func (srv *Server) setupConn(c *conn, flags connFlag, dialDest *discover.Node) error {
    ...
    // 从这里开始,其实已经开始了ethereum的自有协议,doEncHandshake是RLPX协议的握手方法
    if c.id, err = c.doEncHandshake(srv.PrivateKey, dialDest); err != nil {
        srv.log.Trace("Failed RLPx handshake", "addr", c.fd.RemoteAddr(), "conn", c.flags, "err", err)
        return err
    }
    ...
    // 两次握手消息代码(handshakeMsg = 0x00)和(discMsg = 0x01)
    phs, err := c.doProtoHandshake(srv.ourHandshake)
    ...
    // 握手完毕,将新连接对象*p2p.conn压入server.addpeer
    err = srv.checkpoint(c, srv.addpeer)
    // If the checks completed successfully, runPeer has now been
    // launched by run.
    return nil
}
</code></p>

<p>下面开始看<code>Start()</code>函数里的节点主逻辑,主逻辑位于<code>Start()</code>末尾的<code>srv.run()</code>,该函数逻辑较复杂,我们现在主要看新peer接入的代码:</p>

<p>```go 
func (srv *Server) run(dialstate dialer) {
      …
      select{
          …
          case c := &lt;-srv.addpeer:  // 在这里取出之前压入addpeer的连接对象conn
          // 执行到这里表明握手完成,并且通过了节点验证
          err := srv.protoHandshakeChecks(peers, c)
          if err == nil {
              // 创建节点peer对象,传入所有子协议实现,自己实现的子协议就是在这里传入peer的,传入的所以协议通过matchProtocols函数格式化组织
              p := newPeer(c, srv.Protocols)
              …
              go srv.runPeer(p)
          }
          …
      }
      …</p>

<p>}
```</p>

<p>这里补充说一下<code>newPeer()</code>对子协议的一个组织方式:</p>

<p>```go
func matchProtocols(protocols []Protocol, caps []Cap, rw MsgReadWriter) map[string]<em>protoRW {
    // 按协议(name asc,version asc)排序子协议
    sort.Sort(capsByNameAndVersion(caps))
    // 自定义协议偏移
    offset := baseProtocolLength
    result := make(map[string]</em>protoRW)</p>

<p>outer:
    for _, cap := range caps {
        for _, proto := range protocols {
            if proto.Name == cap.Name &amp;&amp; proto.Version == cap.Version {
                // If an old protocol version matched, revert it
                if old := result[cap.Name]; old != nil {
                    offset -= old.Length
                }
                // Assign the new match
                result[cap.Name] = &amp;protoRW{Protocol: proto, offset: offset, in: make(chan Msg), w: rw}
                offset += proto.Length</p>

<pre><code>            continue outer
        }
    }
}
return result } ```
</code></pre>

<p>最终每个子协议以<code>name=&gt;protocol</code>的map格式组织起来,然后每个协议根据自身支持消息类型数量<code>Protocol.Length</code>在整个以太坊消息类型轴上占据了<code>[proto.offset,proto.offset+proto.Length)</code>的左闭右开消息类型段,理解这个结构,才好理解最终根据消息类型<code>Msg.Code</code>去找handler的逻辑(<code>func (p *Peer) getProto(code uint64) (*protoRW, error)</code>)。</p>

<p>下面继续看最终peer处理逻辑<code>srv.runPeer</code>:</p>

<p>```go
func (p *Peer) run() (remoteRequested bool, err error) {
    …
    // peer逻辑里最重要两个循环逻辑</p>

<pre><code>// 收取消息循环,核心逻辑是根据消息的代号proto, err := p.getProto(msg.Code),
// 取得对应的子协议,然后投放到对应协议的读队列proto.in &lt;- msg
go p.readLoop(readErr)
// 不停发送ping心跳包到远端peer
go p.pingLoop()

// 在startProtocols里最终调用我们自定义子协议的Run方法proto.Run(p, rw)
p.startProtocols(writeStart, writeErr)
... } ```
</code></pre>

<h1 id="rlp">数据传输格式RLP</h1>

<p>以太坊数据传输都是基于RLP编码,下面文字摘自<a href="http://ethfans.org/posts/415">RLP编码原理</a></p>

<blockquote>
  <p>RLP(Recursive Length Prefix，递归长度前缀)是一种编码算法，用于编码任意的嵌套结构的二进制数据，它是以太坊中数据序列化/反序列化的主要方法，区块、交易等数据结构在持久化时会先经过RLP编码后再存储到数据库中</p>
</blockquote>

<p>定义</p>

<blockquote>
  <p>RLP编码的定义只处理两类数据：一类是字符串（例如字节数组），一类是列表。字符串指的是一串二进制数据，列表是一个嵌套递归的结构，里面可以包含字符串和列表，例如<code>["cat",["puppy","cow"],"horse",[[]],"pig",[""],"sheep"]</code>就是一个复杂的列表。其他类型的数据需要转成以上的两类，转换的规则不是RLP编码定义的，可以根据自己的规则转换，例如struct可以转成列表，int可以转成二进制（属于字符串一类），以太坊中整数都以大端形式存储。</p>
</blockquote>

<p>这部分代码均位于<code>github.com/ethereum/go-ethereum/rlp</code>包中,代码相对独立,我也没深入研究改算法,就不详细说明了。</p>

<h1 id="section">总述</h1>

<p>本文主要梳理了以太坊p2p模块的主流程,描述了核心的peer间数据读写的来龙去脉,从代码里也能够比较容易理解以太坊子协议的概念,理清这个主干流程,以后也就能够从每个细节发散开来,深入细节。</p>

<h1 id="section-1">参考文献</h1>

<ul>
  <li><a href="https://github.com/ethereum/go-ethereum">go-ethereum github地址</a></li>
  <li><a href="https://github.com/ethereum/go-ethereum/wiki/Peer-to-Peer">Peer to Peer</a></li>
  <li><a href="http://blog.csdn.net/teaspring/article/details/78455046">基于p2p的底层通信</a></li>
  <li><a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-RLP">RLP</a></li>
  <li><a href="http://ethfans.org/posts/415">RLP编码原理</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[p2p之UDP打洞]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/"/>
    <updated>2018-01-26T22:03:15+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong</id>
    <content type="html"><![CDATA[<p>当今互联网到处存在着一些中间件(MIddleBoxes)，如NAT和防火墙，导致两个(不在同一内网)中的客户端无法直接通信。 这些问题即便是到了IPV6时代也会存在，因为即使不需要NAT，但还有其他中间件如防火墙阻挡了链接的建立。 目前部署的中间件多都是在C/S架构上设计的，其中相对隐匿的客户机主动向周知的服务端(拥有静态IP地址和DNS名称)发起链接请求。 大多数中间件实现了一种非对称的通讯模型，即内网中的主机可以初始化对外的链接，而外网的主机却不能初始化对内网的链接， 除非经过中间件管理员特殊配置。</p>

<p>在中间件为常见的NAPT的情况下（也是本文主要讨论的），内网中的客户端没有单独的公网IP地址， 而是通过NAPT转换，和其他同一内网用户共享一个公网IP。这种内网主机隐藏在中间件后的不可访问性对于一些客户端软件如浏览器来说 并不是一个问题，因为其只需要初始化对外的链接，从某方面来看反而还对隐私保护有好处。然而在P2P应用中， 内网主机（客户端）需要对另外的终端（Peer）直接建立链接，但是发起者和响应者可能在不同的中间件后面， 两者都没有公网IP地址。而外部对NAT公网IP和端口主动的链接或数据都会因内网未请求被丢弃掉。本文讨论的就是如何跨越NAT实现内网主机直接通讯的问题。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">网络模型</a></li>
  <li><a href="#section-1">打洞流程</a></li>
  <li><a href="#section-2">先决条件</a></li>
  <li><a href="#section-3">源码示例</a></li>
  <li><a href="#udptcp">udp打洞转tcp通信</a></li>
  <li><a href="#section-4">参考文献</a></li>
</ul>

<h1 id="section">网络模型</h1>

<p>假设客户端A和客户端B的地址都是内网地址，且在不同的NAT后面。A、B上运行的P2P应用程序和服务器S都使用了UDP端口9982，A和B分别初始化了 与Server的UDP通信，地址映射如图所示:</p>

<p><code>
                            Server S
                        207.148.70.129:9981
                               |
                               |
        +----------------------|----------------------+
        |                                             |
      NAT A                                         NAT B
120.27.209.161:6000                            120.26.10.118:3000
        |                                             |
        |                                             |
     Client A                                      Client B
  10.0.0.1:9982                                 192.168.0.1:9982
</code></p>

<p>现在假设客户端A打算与客户端B直接建立一个UDP通信会话。如果A直接给B的公网地址120.26.10.118:3000发送UDP数据，NAT B将很可能会无视进入的 数据（除非是Full Cone NAT），因为源地址和端口与S不匹配，而最初只与S建立过会话。B往A直接发信息也类似。</p>

<p>假设A开始给B的公网地址发送UDP数据的同时，给服务器S发送一个中继请求，要求B开始给A的公网地址发送UDP信息。A往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话，B往A亦然。一旦新的UDP会话在两个方向都打开之后，客户端A和客户端B就能直接通讯， 而无须再通过引导服务器S了。</p>

<p>UDP打洞技术有许多有用的性质。一旦一个的P2P链接建立，链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞， 极大减少了服务器的负载。应用程序不需要知道中间件具体是什么（如果有的话），因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路。</p>

<h1 id="section-1">打洞流程</h1>

<p>假设A现在希望建立一条到B的udp会话，那么这个建立基本流程是:</p>

<p><code>
1. A,B分别建立到Server S的udp会话,那么Server S此时是知道A,B各自的外网ip+端口
2. Server S在和B的udp会话里告诉A的地址(外网ip+端口: 120.27.209.161:6000),同理把B的地址(120.26.10.118:3000)告诉A
3. B向A地址(120.27.209.161:6000)发送一个"握手"udp包,打通A-&gt;B的udp链路
4. 此时A可以向B(120.26.10.118:3000)发送udp包,A-&gt;B的会话建立成功
</code></p>

<h1 id="section-2">先决条件</h1>

<p>能够完成打洞有几个先决条件:</p>

<p><code>
1. A,B所在的nat网络类型(Full cone, Restricted cone, Port-restricted cone, Symmetric NAT)
2. 在一次udp会话期间,nat设备(路由器)会保持内网进程 inner_ip:inner_port &lt;-&gt; share_public_ip:share_port的映射关系,一般根据具体路由器实现,这个映射关系可以维持几分钟到几个小时不等
3. 流程中第3步,nat A收到这个握手包后并不会转发给A,因为它发现自己的没有保存过B的地址,认为这是一个来历不明的包而直接丢弃,然而这个包的作用在于在nat B留下了A的记录,使得nat B认为A是可达或者说可通过了,这样当A-&gt;B再发送udp包时就可以真正到达B了。所以这个"握手"包的作用是可以打通A-&gt;B的通路,是必要的
</code></p>

<h1 id="section-3">源码示例</h1>

<p>使用三台设备模拟,外网设备207.148.70.129模拟Server S,执行server.go代码:</p>

<p>```go server.go 
package main</p>

<p>import (
	“fmt”
	“log”
	“net”
	“time”
)</p>

<p>func main() {
	listener, err := net.ListenUDP(“udp”, &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	log.Printf(“本地地址: &lt;%s&gt; \n”, listener.LocalAddr().String())
	peers := make([]net.UDPAddr, 0, 2)
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf(“error during read: %s”, err)
		}
		log.Printf(“&lt;%s&gt; %s\n”, remoteAddr.String(), data[:n])
		peers = append(peers, *remoteAddr)
		if len(peers) == 2 {</p>

<pre><code>		log.Printf("进行UDP打洞,建立 %s &lt;--&gt; %s 的连接\n", peers[0].String(), peers[1].String())
		listener.WriteToUDP([]byte(peers[1].String()), &amp;peers[0])
		listener.WriteToUDP([]byte(peers[0].String()), &amp;peers[1])
		time.Sleep(time.Second * 8)
		log.Println("中转服务器退出,仍不影响peers间通信")
		return
	}
} } ```
</code></pre>

<p>另外两台分别位于不同内网后的设备,均运行相同代码peer.go:</p>

<p>```go peer.go
package main</p>

<p>import (
	“fmt”
	“log”
	“net”
	“os”
	“strconv”
	“strings”
	“time”
)</p>

<p>var tag string</p>

<p>const HAND_SHAKE_MSG = “我是打洞消息”</p>

<p>func main() {
	// 当前进程标记字符串,便于显示
	tag = os.Args[1]
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9982} // 注意端口必须固定
	dstAddr := &amp;net.UDPAddr{IP: net.ParseIP(“207.148.70.129”), Port: 9981}
	conn, err := net.DialUDP(“udp”, srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	if _, err = conn.Write([]byte(“hello, I’m new peer:” + tag)); err != nil {
		log.Panic(err)
	}
	data := make([]byte, 1024)
	n, remoteAddr, err := conn.ReadFromUDP(data)
	if err != nil {
		fmt.Printf(“error during read: %s”, err)
	}
	conn.Close()
	anotherPeer := parseAddr(string(data[:n]))
	fmt.Printf(“local:%s server:%s another:%s\n”, srcAddr, remoteAddr, anotherPeer.String())</p>

<pre><code>// 开始打洞
bidirectionHole(srcAddr, &amp;anotherPeer)
</code></pre>

<p>}</p>

<p>func parseAddr(addr string) net.UDPAddr {
	t := strings.Split(addr, “:”)
	port, _ := strconv.Atoi(t[1])
	return net.UDPAddr{
		IP:   net.ParseIP(t[0]),
		Port: port,
	}
}</p>

<p>func bidirectionHole(srcAddr *net.UDPAddr, anotherAddr *net.UDPAddr) {
	conn, err := net.DialUDP(“udp”, srcAddr, anotherAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	// 向另一个peer发送一条udp消息(对方peer的nat设备会丢弃该消息,非法来源),用意是在自身的nat设备打开一条可进入的通道,这样对方peer就可以发过来udp消息
	if _, err = conn.Write([]byte(HAND_SHAKE_MSG)); err != nil {
		log.Println(“send handshake:”, err)
	}
	go func() {
		for {
			time.Sleep(10 * time.Second)
			if _, err = conn.Write([]byte(“from [” + tag + “]”)); err != nil {
				log.Println(“send msg fail”, err)
			}
		}
	}()
	for {
		data := make([]byte, 1024)
		n, _, err := conn.ReadFromUDP(data)
		if err != nil {
			log.Printf(“error during read: %s\n”, err)
		} else {
			log.Printf(“收到数据:%s\n”, data[:n])
		}
	}
}
```</p>

<p>注意代码仅模拟打洞基础流程,如果读者测试网络情况较差发生udp丢包,可能看不到预期结果,此时简单重启server,peer即可.</p>

<p>完整代码参考<a href="https://github.com/qjpcpu/p2pbyudp">github</a></p>

<h1 id="udptcp">udp打洞转tcp通信</h1>

<p>通常,由于udp打洞实现简单,p2p的实现采用udp打洞较多,然而当通路建立起来后使用tcp进行节点间通信可以获取更好的通信效果。因为udp打洞完成后形成的nat映射是和tcp/udp无关的,所以此时可以转为使用tcp建立连接,达到最终的p2p的tcp通信.由于代码较简单,这里就不给出示例了。</p>

<h1 id="section-4">参考文献</h1>

<ul>
  <li><a href="https://yq.aliyun.com/articles/227421">UDP用打洞技术穿透NAT的原理与实现</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/26796476">P2P通信原理与实现</a></li>
  <li><a href="https://github.com/jtriley/pystun">NAT类型检测工具</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
