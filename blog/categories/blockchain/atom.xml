<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: blockchain | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2022-09-10T08:30:34+00:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ethereum挖矿流程]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/11/15/ethereumwa-kuang-liu-cheng/"/>
    <updated>2018-11-15T09:50:36+00:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/11/15/ethereumwa-kuang-liu-cheng</id>
    <content type="html"><![CDATA[<p>本文主要梳理eth挖矿的代码流程结构。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#newworkloop">协程1. newWorkLoop</a></li>
  <li><a href="#mainloop">协程2. mainLoop</a></li>
  <li><a href="#taskloop">协程3. taskLoop</a></li>
  <li><a href="#resultloop">协程4. resultLoop</a></li>
  <li><a href="#update">协程5. update</a></li>
</ul>

<p><img src="https://upload-images.jianshu.io/upload_images/14928134-15681166031820cd.gif?imageMogr2/auto-orient/strip" alt="miners" /></p>

<p><img src="https://upload-images.jianshu.io/upload_images/14928134-43aa117385c9baea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="global.png" /></p>

<p>geth的挖矿逻辑都由<code>miner.Miner</code>结构管理，在程序启动时，miner主要启动了5个核心协程并行处理挖矿逻辑，其中挖矿worker负责维护4个最关键协程。</p>

<h2 id="newworkloop">协程1. newWorkLoop</h2>

<p><img src="https://upload-images.jianshu.io/upload_images/14928134-9d834bbc88ede0cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="work ch.png" /></p>

<p>该协程负责周期性地提交新的挖矿任务。当程序启动或者区块同步完成，或者新区块挖掘完毕，<code>miner.start()</code>方法会被调用，则<code>startCh</code>通道激活，此时协程清理过期的挖矿任务，构建新的挖矿任务并投递到新任务通道<code>newWorkCh</code>，等待挖矿执行。</p>

<h2 id="mainloop">协程2. mainLoop</h2>

<p>挖矿的主要逻辑都位于该协程。</p>

<p>该协程监听<code>newWorkCh</code>通道，接收到新挖矿请求后，开始挖矿。挖矿的逻辑位于<code>commitNewWork</code>函数内，如下图所示，首先准备区块头，调用共识引擎<code>engine.Prepare</code>准备共识信息，目前的共识使用了PoW共识算法，主要是为区块头计算出本次需要满足的区块PoW难度并写入到区块头；然后再讲收集到达叔区块引入，注意，以太坊最多只能引用2个叔区块，此外，优先引用本地叔区块再引入远端叔区块；然后开始执行收集到pending队列里的交易，也是本地优先远端执行；最后，进行交易后处理，这里也是调用共识引擎<code>engine.Finalize</code>实现，主要功能是计算矿工奖励；最后把封装好的区块投递到<code>taskCh</code>通道等待挖矿计算验证。</p>

<p><img src="https://upload-images.jianshu.io/upload_images/14928134-a1898acd67116a44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="commitNewWork.png" /></p>

<p>同时还监听<code>chainSideCh</code>通道，再检测到叔区块后，如果当前正在挖矿就提交新的叔区块并重新挖矿。</p>

<p>在监听<code>txsCh</code>通道时，收到新交易后，如果当前正在挖矿，则执行新交易并重新挖矿，否则直接触发一次新挖矿。</p>

<p>该协程主要都是收集不同信息(交易，叔区块)并封装区块，投递到任务通道准备共识计算。</p>

<p><img src="https://upload-images.jianshu.io/upload_images/14928134-85f3a82dfefc6ffe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="task ch.png" /></p>

<p>另外，这里有个问题，如果前面一个共识计算正在进行中，此时收到新交易或新uncle则立刻进行新的区块，而这两次计算都是针对同一区块(高度)，这样岂不是必然有一次计算浪费？</p>

<h2 id="taskloop">协程3. taskLoop</h2>

<p>这一步是挖矿的核心，然而从流程上却是最简单的，就是从<code>taskCh</code>获取封装好的区块，进行共识计算，并将成功的结果投递到<code>resultCh</code>。</p>

<p><img src="https://upload-images.jianshu.io/upload_images/14928134-0413b576462ff621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result ch.png" /></p>

<h2 id="resultloop">协程4. resultLoop</h2>

<p><img src="https://upload-images.jianshu.io/upload_images/14928134-ec254a1543e30cf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区块挖出来之后.png" /></p>

<p>该协程将达成共识的区块(即成功挖出的区块)写入DB,并且向周边p2p节点广播<code>NewMinedBlockEvent</code>，然后触发链变更事件(<code>ChainEvent</code>+<code>ChainHeadEvent</code>或<code>ChainSideEvent</code>)，最后将区块插入待确认区块集合。</p>

<ol>
  <li>为什么<code>resultLoop</code>变更链事件触发有两种情况(<code>ChainEvent</code>+<code>ChainHeadEvent</code>)或(<code>ChainSideEvent</code>) ?</li>
</ol>

<p>这是因为写入DB时，会进行链分叉判断，如果当前写入的链难度低，说明需要进行链重组，则次数会导致触发<code>ChainSideEvent</code>事件。</p>

<p>另外，注意如果发生链重组，则会从删除旧链的交易:</p>

<p><code>go
// reorgs takes two blocks, an old chain and a new chain and will reconstruct the blocks and inserts them
// to be part of the new canonical chain and accumulates potential missing transactions and post an
// event about them
func (bc *BlockChain) reorg(oldBlock, newBlock *types.Block) error {
    // .......
	for _, tx := range diff {
		rawdb.DeleteTxLookupEntry(batch, tx.Hash())
	}
    // ......
}
</code></p>

<p>那么删除的交易再什么时候被重新打包的呢？答案是，<code>txpool</code>监听了<code>ChainHeadEvent</code>事件，当接收到新区块时，会进行分叉判断，再此时会将之前<code>删除的交易</code>重新放入交易池等待打包</p>

<p>```go</p>

<p>// reset retrieves the current state of the blockchain and ensures the content
// of the transaction pool is valid with regard to the chain state.
func (pool *TxPool) reset(oldHead, newHead *types.Header) {
	// If we’re reorging an old state, reinject all dropped transactions
	var reinject types.Transactions
    // ….
	// Inject any transactions discarded due to reorgs
	log.Debug(“Reinjecting stale transactions”, “count”, len(reinject))
	senderCacher.recover(pool.signer, reinject)
	pool.addTxsLocked(reinject, false)
    // …
}
```</p>

<ol>
  <li>区块什么时候从<code>unconfirmed</code>集合移除?</li>
</ol>

<p>答案是插入即确认，这个队列时环形的，并且矿工在创建<code>unconfirmed</code>队列会指定长度，这个长度即确认高度，当超过这个高度的区块被插入，自然就有最早的区块被移除，达到天然确认的目的。</p>

<h2 id="update">协程5. update</h2>

<p>该协程主要保证区块同步和挖矿互斥进行，即同步区块时暂停挖矿，同步完毕启动挖矿。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在这里,读懂区块链]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/09/18/qu-kuai-lian-you-qian-ru-shen/"/>
    <updated>2018-09-18T07:08:00+00:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/09/18/qu-kuai-lian-you-qian-ru-shen</id>
    <content type="html"><![CDATA[<p>读懂区块链——仅需这一篇。(草稿，内容整理中…)</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">前言</a></li>
  <li><a href="#section-1">入门篇</a>    <ul>
      <li><a href="#section-2">什么是区块链?</a>        <ul>
          <li><a href="#section-3">场景</a></li>
          <li><a href="#section-4">先找到问题</a></li>
          <li><a href="#section-5">分析问题</a>            <ul>
              <li><a href="#section-6">1. 去除中心化机构</a></li>
              <li><a href="#section-7">2. 账户凭证问题</a></li>
              <li><a href="#section-8">3. 记账权</a></li>
            </ul>
          </li>
          <li><a href="#section-9">求解问题</a></li>
          <li><a href="#section-10">什么是区块链</a>            <ul>
              <li><a href="#section-11">比特币</a>                <ul>
                  <li><a href="#section-12">1. 交易</a></li>
                  <li><a href="#section-13">2. 工作量证明</a></li>
                </ul>
              </li>
              <li><a href="#section-14">智能合约</a></li>
            </ul>
          </li>
          <li><a href="#xxx">保证xxx不可篡改</a></li>
        </ul>
      </li>
      <li><a href="#section-15">区块链能做什么?</a>        <ul>
          <li><a href="#section-16">1. 需要去中心化</a></li>
          <li><a href="#section-17">2. 处于不受信环境下</a></li>
          <li><a href="#section-18">3. 性能要求不高</a></li>
        </ul>
      </li>
      <li><a href="#section-19">区块链不能做什么?</a></li>
      <li><a href="#section-20">区块链生态</a>        <ul>
          <li><a href="#section-21">矿工节点</a></li>
          <li><a href="#section-22">智能合约</a></li>
          <li><a href="#sdk">SDK</a></li>
          <li><a href="#dapp">DApp</a></li>
          <li><a href="#section-23">钱包</a></li>
          <li><a href="#section-24">交易所</a></li>
          <li><a href="#section-25">用户</a></li>
        </ul>
      </li>
      <li><a href="#section-26">几条著名公链</a>        <ul>
          <li><a href="#btc">BTC</a></li>
          <li><a href="#ethereum">Ethereum</a></li>
          <li><a href="#eos">EOS</a></li>
          <li><a href="#ont">ONT</a></li>
          <li><a href="#bch">BCH</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-27">进阶篇</a>    <ul>
      <li><a href="#utxobalance">UTXO/Balance两种模型</a></li>
      <li><a href="#section-28">分叉</a>        <ul>
          <li><a href="#section-29">软分叉</a></li>
          <li><a href="#section-30">硬分叉</a></li>
        </ul>
      </li>
      <li><a href="#section-31">共识机制</a>        <ul>
          <li><a href="#pow">POW</a></li>
          <li><a href="#pos">POS</a></li>
          <li><a href="#dpos">DPOS</a></li>
          <li><a href="#pbft">PBFT</a></li>
        </ul>
      </li>
      <li><a href="#section-32">51%与双花</a></li>
      <li><a href="#zcash">零知识证明与zcash</a></li>
      <li><a href="#section-33">环形签名与门罗币</a></li>
      <li><a href="#p2p">P2P</a></li>
      <li><a href="#section-34">联盟链</a>        <ul>
          <li><a href="#quorum">quorum</a></li>
          <li><a href="#hyperledger-fabric">Hyperledger Fabric</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-35">参考文献</a></li>
</ul>

<h1 id="section">前言</h1>

<p>撰写这篇文章的原因，一是想向对不了解区块链的同学介绍下这项技术，二也是借机进行一次知识梳理,所以，有理解错误的地方，也希望读者不吝指正。</p>

<p><strong>对于读者群</strong>:</p>

<p>因为有的读者是非技术类的，所以我将内容拆分成入门和进阶两部分,在入门篇里我尽量不涉及计算机技术术语，其细节我会放到进阶篇；同时，我也不希望进阶篇变成学术论文，所以进阶篇里会从逻辑层面解释原理，不会涉及数学公式,我并不希望读者睡着了。</p>

<p>所以,不想了解技术细节的同学，读完入门篇就够了;而对于有进一步探索欲望的同学，进阶篇也有足够指向作用了。</p>

<p><strong>链种</strong>:</p>

<p>目前区块链分为公链、联盟链、私链，本文主要介绍公链，并稍微提及联盟链，不会涉及私链。</p>

<p>废话不多说, let’s start now.</p>

<h1 id="section-1">入门篇</h1>

<h2 id="section-2">什么是区块链?</h2>

<p>我想每个人第一次听到区块链这三个字的时候，第一反应都是本能地问出:区块链是什么? <strong>What</strong>永远是人类认识事物的第一步,那么怎么回答这个问题呢。其实无论是回答什么”去中心化的信任机制”还是”分布式账本”，我相信听众脸上懵比的问号只会更大。所以我们尝试还原区块链产生的场景，了解这项技术产生的背景，从而回答它是什么。</p>

<h3 id="section-3">场景</h3>

<p>Clark是居住在大都会一个普通小伙子，他在星球日报勤勤恳恳地工作，把他辛苦挣来的钱都存入大都会银行，这家银行由大银行家Luthor筹建，是大都会最大最安全的银行,大都会居住的人们都喜欢把他们的资金存入这家银行，他们都信任这家银行，祖祖辈辈都离不开这家银行,Luthor确实也将银行经营得很好。</p>

<p>然而，不久后大都会发生了外星人入侵事件，所幸的是大都会人们还是挺过了这场灾难。不过大都会遭受了巨大的经济损失，经济发生萧条。这其中蒙受损失的，自然也包括大都会银行，Luthor为了维护自身的利益，不顾一切开始大量增发货币。这下Clark发现自己本就不多的存款变得一文不值，更为雪上加霜的是，灾后他去查自己的银行账户的时候，发现自己账户余额为零,而Luthor给Clark的解释是，入侵事件毁坏了银行部分数据，因而luthor无法恢复clark的财产，甚至也拒绝支付赔偿。</p>

<p>Clark听到这一切，无助地瘫倒在地，口中喃喃:这可是我攒来娶Louis的老本啊…</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/clark-luthor.jpg" alt="clarkVSluthor" /></p>

<h3 id="section-4">先找到问题</h3>

<p>那么，Clark遇到的问题所在在哪儿呢？Clark找到好友Bruce,助他度过了当前难关，但是还是不知道怎么在同样情况下避免财务危机。这个时候，Bruce一针见血地指出了问题所在:</p>

<p><strong>中心化信任危机</strong></p>

<p>Luthor所代表的大都会银行，广义来讲就是中心化的权威机构。所有中心机构的用户，都是基于信任将资金托管给该机构，但是信任是不可靠的，一旦发生信任危机，中心化机构可以打破信任，对于银行来说可以不受限制地增发货币甚至直接侵吞私有财产。你可能会说有法律保护，但是这个时候其实是国家在为这个机构背书，国家机器充当了这个隐形的中心化信任载体。尽管国家违约成本比较高，但只要翻翻历史书，就会发现这样的案例也不在少数。</p>

<h3 id="section-5">分析问题</h3>

<p>既然找到问题所在，那么应该怎么设计新的解决方案呢？</p>

<h4 id="section-6">1. 去除中心化机构</h4>

<p>如果问题出在中心化机构，那么很自然的就需要在我们的解决方案里移除对中心化机构的信任依赖。</p>

<p>那么我们就每个人都持有一个账本，并且每个账本初始数据都一模一样;比如是这样的一个账本:</p>

<p><code>
Bruce inital 1
Clark inital 10000
...
</code></p>

<p>一旦发生转账，比如Bruce要给Clark转账200，那么所有人都在账本上写上一句<code>Bruce transfer 200 to Clark</code>。 那么账本就变成了</p>

<p><code>
Bruce inital 1
Clark inital 10000
...
Bruce transfer 200 to Clark
</code></p>

<p>此时，如果我们想知道Clark的账户余额，只需要把和Clark相关的记账账目汇总即可得到<code>Balance(Clark) = 1 + 200 = 201</code>,这个结果不容任何人抵赖，因为你问大街上任意一个人，只要他打开他的账本，按同样的方法计算都可以得出Clark账户余额是201这个结果。</p>

<h4 id="section-7">2. 账户凭证问题</h4>

<p>去除中心化之后，似乎我们的问题解决了。因为就算再次发生入侵，只要不是所有人的账本都损坏了，那么我们就可以找账本完好的人把之前的账目抄下来恢复自己的账本，从而恢复所有人的资产记录。</p>

<p>但是实际上没有那么简单，如果有人冒充Bruce要求转账给Clark,那么Bruce就在不知情的情况下被盗取了财产。所以，我们借鉴了现实生活中签名的办法，要求Bruce在转账的时候必须附加自己的签名，然后将这笔转账和签名一起广播出去。这样大家记账的时候就能验证，的确是Bruce本人要求的转账。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/bruce-sign.png" alt="bruce-sign" /></p>

<h4 id="section-8">3. 记账权</h4>

<p>在我们新的解决方案里，我们需要交易发起人广播给其他所有记账人，实际上，这个广播不可能一瞬间将交易发给所有人。这个广播系统可以这样理解，假设我们都使用蓝牙协议作为通信基础，这个系统里每个人都使用蓝牙和身边十来个人保持连接，同理这些人和各自身边的人保持连接，这样所有人构成一个互联的网状结构。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/bluetooth-p2p.png" alt="blockchain" /></p>

<p>因为交易信息传播有时间延迟，所以，同一时刻，系统里每个人收到的记账请求是不一样的。那么，我们一开始设计的所有人一起记账就行不通了，因为这样写到账本里的账目就不同了。为了大家写入同样的数据，必须能一起协调出统一的账目，然后写入。因为现在是一个大民主的社群，必须有一种投票机制选出一个记账人，这个记账人负责整理这段时间内收到的记账请求，并把这些账目一起写入账本;我们称之为争夺记账权。</p>

<p>那么，怎么设计这个记账权争夺机制呢？</p>

<ul>
  <li>首先必须要公平，不能因为某个记账人的社会地位高就能够拥有记账权；因为这样就会再次导致记账中心化，从而使得我们这个去中心化的解决方案失效</li>
  <li>机制必须透明，机制的透明是对公平性的验证，我们的解决方案里必须能够让所有人能够验证这个公平性是否属实</li>
  <li>筛选性，既然是记账权的争夺，这个机制必然具有强烈的优胜劣汰性质，否则达不到筛选出冠军的目的</li>
  <li>冠军身份易于验证，就如同一场长跑，争夺冠军是非常艰难的，但是一旦夺得胜利，我们能一眼分辨出谁是冠军——谁戴着奖牌谁是冠军</li>
</ul>

<p>明确了这个设计需求，我们留到求解问题时再进行解答。</p>

<p>但是基于我们这个设计，又带来了新的问题，如果记一次帐这么费劲，那肯定最后没人愿意记账了。中国有句老话说得好: 无利不起早，现实生活中大部分人的行为都是趋利的。所以，我们这个解决方案里，还差最后一环——经济激励。</p>

<p>如果我们这个解决方案里，大家约定，一旦某个天选之子夺得了记账权并成功记账，那么就给予他额外现金奖励，这个奖励足够补偿他这次辛苦记账的付出,这样，整个流程似乎就理顺了。</p>

<h3 id="section-9">求解问题</h3>

<p>在开始执行求解前，我们先复盘一下我们的思路，看看是否有思路不通畅的地方，防止出现逻辑漏洞。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/thoughts-flow.jpeg" alt="blockchain" /></p>

<p>这是一条由问题驱动的推导型思路，主要是为了解决我们发现的中心化问题，在提出新的解决方案并解决新的衍生问题，主体上看来没有大的疏漏。</p>

<p>还有一开始我们遇到的两个问题，我们看看新的解决方案是否能解决:</p>

<p>第一，货币的增发问题</p>

<p>大都会银行作为中心化的机构，可以随意增发货币原因在于,它是货币的发行方，其他人无法拒绝或者阻止其增发行为。但是如果在新的解决方案里，我们将货币增发(其实就是这个争夺记账的经济奖励)的规则写入印刷到每个人账本的扉页，如果有个不诚实的记账者，在记账时私自增大自己的经济奖励，那么当他将自己写下的这页账目传播给别人时，其他人发现这个激励金额不符合扉页的激励规则，就会拒绝写入自己的账本，这样这个不诚实者因为其账目作弊，他的账本也成为废账，也就无法获得这部分”非法收入”了。</p>

<p>第二, 资产无法被篡改</p>

<p>首先，每个人的账户是无法被销毁的，因为要销毁账目记录，就意味着要修改所有人手里的账本，这几乎是不可能的。再者，只有自己签名的交易申请才会被记录入账本，其他人无法伪造自己的签名，从而也就无法篡改账本上别人的账目记录，换句话说，只有自己可以修改自己的账户余额，其他人试图更改别人的账户余额是一定会被拒绝入账的。</p>

<p>下面我们开始来求解遗留的记账争夺问题。</p>

<p>因为大都会市民极其不擅长数学，所以，我们使用求余来作为这场争夺的题目。比如每次记账，要求大家求解<code>x % 7 = 3</code>满足这个等式的<code>x</code>,因为大家数学很差，所以大家不得不一个一个数去尝试，当某个幸运儿最先发现<code>10 % 7 = 3</code>时，他就获取了记账权，而其他人将<code>x=10</code>带进算式很容易验算出这是符合条件的一个求解，所以大家也就表示认同，同时也认可了他的记账。于是所有人复制他记下的账目，并开始收集新的交易流水，准备下一次记账。</p>

<p>最后，我们将我们这个解决方案称之为”区块链”，这个解决方案里的很多做法其实就是真实区块链技术的简化版:</p>

<ul>
  <li>区块链; 我们的记账笔记薄就是一条区块链，这里面从前往后记录了所有人的所有账目流水，后面的账目对前面的账目有依赖关系</li>
  <li>区块; 账本的每一页，可以称之为一个区块，页码可以认为是区块前后的索引关系</li>
  <li>交易; 账本每一页的每一条都是一笔交易，这个交易可以是一笔简单转账，也可以是一次协定</li>
  <li>数字签名; 还记得我们要求每笔交易发送时必须附加自己的签名吗？在数字世界里，我们必须附加自己的<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0">数字签名</a>,这个签名甚至比真实世界的签名更可靠，它基于密码学，不可伪造且能唯一证明你的授权</li>
  <li>挖矿; 我们的争夺记账权的过程，和矿工付出辛劳挖矿非常相似，所以也称之为挖矿了。不过真实的区块链挖矿使用的不是求余这么简单的运算，而是反解hash前缀0的暴力运算</li>
  <li>矿工; 从事争夺记账权的节点(人)</li>
  <li>虚拟货币; 不管是矿工挖矿得到的额外经济奖励，还是账本上记录的基本代数资产，都是这条区块链上的虚拟货币；比如比特币区块链上的虚拟货币就是BTC, 以太坊上的货币就是ETH</li>
  <li>共识机制; 争夺记账权的机制就是共识机制，因为争夺机制的差异，目前有PoW,PoS等;目前久经考验的共识机制是PoW,我们大都会区块链的共识，也使得矿工付出大量脑力劳动，所以也可以称之为一种PoW</li>
</ul>

<h3 id="section-10">什么是区块链</h3>

<p>回到最初的问题，什么是区块链: </p>

<p><strong>区块链是在对等且不受信环境下, 达成共识保证群体协作的一种社群机制</strong></p>

<p>那么现在是时候看看真实世界的区块链是怎么样的了，自然，这得说说比特币了。下面小节主要取自中本聪的比特币白皮书。</p>

<h4 id="section-11">比特币</h4>

<p>这里是中文版全文<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币白皮书：一种点对点的电子现金系统</a></p>

<h5 id="section-12">1. 交易</h5>

<p>比特币里是这样组织交易的: 每一位所有者通过对前一次交易和下一位拥有者的公钥签署一个哈希数字签名，并将这个签名附加在交易的末尾，交易里包含的数字货币就发送给了下一位所有者。而收款人通过对签名进行检验，就能够验证该交易的合法性。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/btc-tx.png" alt="blockchain" /></p>

<p>白皮书里面这个说法比较拗口。其实是这个意思，交易一定有多笔输入和至少一笔输出，上一笔交易的输出可以作为下一笔交易的输入，交易与交易直接就通过输入输出串联起来。而这个输入输出的本质，其实就是比特币资金的流动。</p>

<p>比如，现在A要给B转账4个比特币，那他要怎么构造这笔交易呢？A在自己钱包里找到一张”面值”为3的比特币和一张”面值”为1的比特币(这里的3和1的比特币其实就是A之前交易的两个输出)，于是A构造一笔交易，交易有两个输入:3、1这个两笔比特币，输出为4比特币，并且这个输出最终能够被B接受并花费。为了保证交易正确串联执行，所以A对B的公钥+交易本身数据做一次数字签名，并将签名附加在交易上，那么B就能对交易进行验证，达到获取这笔交易输出的母的，从而B也就获取了这4个比特币。</p>

<p>比特币里的这种交易设计还能巧妙地解决双花问题: 数字货币的交易说到底也就是一段二进制数据，如果把同样的数据连续发送两份，是不是就能够进行重复支付(double spend),达到”一分钱当两份钱”花了呢。在比特币系统里，因为交易的输入只能使用一次，当第一次交易被区块受理后，第二笔同样交易来到时，矿工发现这笔交易引用的输入已经被花费掉了，就会认为这是一笔非法交易而拒绝掉，所以是不会出现双花问题的。</p>

<h5 id="section-13">2. 工作量证明</h5>

<p>比特币的共识使用了工作量证明(Proof of Work)来实现。</p>

<p>PoW的核心思想是使用反解哈希来达成共识。哈希函数输入一个任意长度的数据，输出一个长度固定且绝不雷同的值，可将其视为输入的数字指纹。对于特定输入，哈希的结果每次都一样，任何人都可以用相同的哈希函数，计算和验证哈希结果。一个加密哈希函数的主要特征就是不同的输入几乎不可能出现相同的数字指纹。因此，有意的选择一个输入去生成一个想要的哈希值值是几乎不可能的，更别提用随机的方式生成想要的哈希值了。</p>

<p>比特币使用SHA256算法，无论输入的大小是多少，SHA256函数的输出的长度总是256bit。</p>

<p>比如计算”I am Satoshi Nakamoto”的sha256哈希值，得到”5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e”,改变原句中的任何一个字母、标点、或增加字母都会产生不同的哈希值,比如我们在原句”I am Satoshi Nakamoto”结尾加一个任意数字，得出的结果是完全没有规律的，不可能根据hash值反推出原句结尾加的是什么数字。</p>

<p>为了使这个哈希算法变得富有挑战，我们来设定一个具有任意性的目标：找到一个语句，使之哈希值的十六进制表示以0开头。幸运的是，这很容易尝试出语句 “I am Satoshi Nakamoto13”的哈希值是”0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5”，刚好满足条件。我们得到它用了13次。用概率的角度来看，如果哈希函数的输出是平均分布的，我们可以期望每16次得到一个以0开头的哈希值（十六进制个位数字为0到 F）。从数字的角度来看，我们要找的是小于 0x1000000000000000000000000000000000000000000000000000000000000000的哈希值。</p>

<p>我们称这个为Target目标阈值，我们的目的是找到一个小于这个目标的哈希值。如果我们减小这个目标值，那找到一个小于它的哈希值会越来越难。</p>

<p>简单打个比方，想象人们不断扔一对骰子以得到小于一个特定点数的游戏。第一局，目标是12。只要你不扔出两个6， 你就会赢。然后下一局目标为11。玩家只能扔10或更小的点数才能赢，不过也很简单。假如几局之后目标降低为了5。</p>

<p>现在有一半机率以上扔出来的骰子加起来点数会超过5，因此无效。随着目标越来越小，要想赢的话，扔骰子的次数会 指数级的上升。最终当目标为2时（最小可能点数），只有一个人平均扔36次或2%扔的次数中，他才能赢。从一个知道骰子游戏目标为2的观察者的角度来看，如果有人要成功中奖，假设他平均尝试了36次。</p>

<p>换句话说，可以估计从实现目标难度取得成功所需的工作量。 当算法是基于诸如SHA256的确定性函数时，输入本身就成为证据，必须要一定的工作量才能产生低于目标的结果。 因此，称之为工作量证明。</p>

<h4 id="section-14">智能合约</h4>

<p>讲到区块链就不得不提智能合约,比特币系统里是没有智能合约的，智能合约是由以太坊带到大众视野里的概念，而反过来以太坊也因为这一创举成为区块链上的无冕之王(有冕的自然是比特币)。不过要提一点，以太坊只是将这个概念带进了现实，但是提出这一概念的并不是以太坊团队，而是1990s年代由尼克萨博提出，只是由于当时缺乏可信的执行环境无法得到应用。</p>

<p>那么智能合约是什么呢？智能合约本质是一段代码，在区块链这个公有环境上运行。</p>

<p>举个例子，如果Bruce和Clark打赌，如果明天下雨就给Clark转账100，那么Bruce可以在大都会区块链上提交这样一笔交易:</p>

<p><code>
Bruce transfer 100 to Clark if it rains tomorrow
</code></p>

<p>这笔交易就是一份智能合约，他发布到区块链上，这份合约就会冻结Bruce账户里100元到合约里,任何人不得篡改，并且这份合约也相当于受到所有人的监督执行。当第二天真的下雨时，Clark就可以收到Bruce输给他的100元，反之如果是个大晴天，那么Clark什么也得不到,bruce也可以解冻并收回这100元。</p>

<p>这个例子能够很直白描述智能合约的功能，但是实际上，区块链作为数字世界的产物，无法和现实世界产生可信关联，所以这种赌约基本上是无法在区块链上实现的。但是如果合约执行条件本身就来自数字世界，那就完全可信了，比如Bruce和Clark对赌的输赢都是由随机数决定。这也是为什么目前博彩类游戏在区块链上高歌猛进的原因。既满足了游戏策略的公平透明,又使得玩家的资金能可靠进出，同时由于数字签名的存在还具有一定的匿名性。</p>

<h3 id="xxx">保证xxx不可篡改</h3>

<p>网上铺天盖地宣传区块链都包含了类似这样的卖点: <strong>数据不可篡改</strong>。其实这是一个非常模糊的概念，区块链真的保证数据不可篡改吗？其实并不是，区块链真正保证的是逻辑不可篡改，而不是数据本身不可篡改。以风靡世界的以太坊迷恋猫为例，迷恋猫的数据如果不可篡改的话，那么怎么保证猫的繁殖和买卖，这些业务行为其实就说明了数据是被改动了的；但是由于区块链(以太坊)保证迷恋猫的游戏逻辑是严格按照智能合约执行，数据一定按照合约制定的逻辑执行，所以大家才放心投入eth去玩这个游戏，而不用担心猫这种资产被盗。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/cryptokitties.jpg" alt="blockchain" /></p>

<p>因此，如果你关心资产是否完全可控，就需要关注项目方提供给你的智能合约是否是留有后门的，否则如果遇到无良开发者卷款潜逃就欲哭无泪了；反观区块链排行榜<a href="https://dappradar.com/">dappradar</a>上，有许多Dapp都是闭源的，到底用户进去会不会被坑，只有听天由命了;甚至于某些公链能允许开发者修改合约逻辑，虽然初衷是为了能够修复区块链合约bug，但是恶意开发者却可以利用这个规则先通过审查再加装后门，总体来说，笔者觉得其实是有违区块链精神。</p>

<h2 id="section-15">区块链能做什么?</h2>

<p>区块链能做什么，就看看它是为了解决什么问题而诞生的就行了</p>

<h4 id="section-16">1. 需要去中心化</h4>

<p>如果没有去中心化的强需求，那么他不需要区块链，一个中心化的权威组织在大部分情况下都能做得更好。</p>

<h4 id="section-17">2. 处于不受信环境下</h4>

<p>如果是一个受信环境，更不需要区块链了，极有可能需要的仅仅是一个分布式数据库。这种场景下，一般是联盟链的工作环境。而且，受信环境下矿工可能本身就受雇于这个某个盈利性组织，所以经济激励也不需要了，所谓的无token区块链一般也是在这种环境下才能存活。</p>

<h4 id="section-18">3. 性能要求不高</h4>

<p>这是区块链目前的现状导致的，也许未来就不存在了。因为存在出块竞争，所以目前公链都有性能问题，如果想基于区块链做一个电商系统，同时又想达到淘宝的交易承载量，那基本是不可能的。有个比较公认的说法，区块链是环保+性能+去中心化三者折衷的结果。</p>

<p>此外，要注意区块链的智能合约不能强依赖于现实世界，原因在于合约代码是明确的，而现实世界的定义是模糊的，即便能够做准确定义，那么将这个现实的信息注入到区块链里，目前除了引用一个权威机构的数据，也没有特别好的办法，所以这又回到要不要去中心化的问题了。</p>

<p>所以，目前看起来，纯线上业务比较适合区块链，比如金融和游戏。以太坊创始人V神在回答王峰十问时，就谈到了这个问题: <a href="http://tech.ifeng.com/a/20180622/45035376_0.shtm">以太坊创始人V神在做客王峰十问时表示，金融业和游戏行业是最先应用区块链技术的两行业</a></p>

<h2 id="section-19">区块链不能做什么?</h2>

<p><strong>真瓶装假酒</strong></p>

<p>我这个观点可能很多人不认同，因为区块链火起来之后，很多人开始做区块链溯源、区块链打车之类的事情，试图以区块链解决信任和防伪的问题。但是实际情况是，这些场景下的问题出在人身上，而不是自动化流程身上，区块链作为一项信息技术是解决不了这个问题的。</p>

<p>打个比方，有人目前在做红酒的区块链溯源防伪，整个流程上链是没有问题的，他做到了保证82年的拉菲的这个酒瓶的确是从产地直接送到顾客手里(甚至这一点都不能保证)，并不能保证酒瓶里就是拉菲而不是长城干红。为什么呢，因为如果我是最后一级经销商，我打开酒瓶喝了拉菲，然后换进去长城干红，然后保证完美重新包装，顾客除非拿到酒喝到嘴里，基本上是分辨不出来的。</p>

<p>这就是之前提到的，区块链无法辨别现实世界的问题。所以，区块链防伪是个伪命题，但是如果做溯源勉强还说得通，那么问题来了，仅仅是做溯源，哪个中心化的系统又做不到呢，如果硬要用区块链，也仅仅是把它作为一个分布式数据库来用罢了。</p>

<h2 id="section-20">区块链生态</h2>

<h3 id="section-21">矿工节点</h3>

<p>矿工只有挖矿才能完成记账，从区块链运行机制上来说，矿工节点记账就是区块链的源动力，它们的挖矿行为就是在保证区块链正常运作不宕机。</p>

<h3 id="section-22">智能合约</h3>

<p>智能合约并不是区块链上所必须的，比如比特币就没有。但是如果区块链想提供除转账外更多的可能，就必须要智能合约来实现了。尤其因为以太坊起了区块链2.0的头，后续新型公链里智能合约基本成为标配,成为驱动去中心化赋能的核心动力。</p>

<h3 id="sdk">SDK</h3>

<p>很多情况下,SDK其实并未直接出现在用户面前，但它其实对生态的发展非常重要，SDK是和智能合约直接对话的工具。SDK是否成熟完善，是吸引开发者重要原因，区块链是社群烘托起来的工具，没有用户何来共识，但如果没有开发者来开发Dapp,又何来用户?</p>

<h3 id="dapp">DApp</h3>

<p>公链是平台，平台建好了，需要在上面开发Dapp,有了百花齐放的Dapp,整个生态才能起来。</p>

<h3 id="section-23">钱包</h3>

<p>钱包是链的基本入口，目前众多公司在数字钱包上竞争，希望能成为区块链上的支付宝，可见钱包的重要性。</p>

<h3 id="section-24">交易所</h3>

<p>作为公链，必然产出虚拟货币。那么虚拟货币必然有个消耗的出口，直接作为支付手段进行消费是一种，另一种就是和法币进行直接或间接兑换。目前由于基础设施的不完善，中心化的交易所不论是规模和影响力都远远超过去中心化交易所，其对区块链施加的影响力甚至超过社群本身，所以某种程度来说，也挺讽刺的。</p>

<h3 id="section-25">用户</h3>

<p>用户位于生态最顶端，也是最重要的一环,所有的底层设施，都是为了吸引用户,用户多了又能反过来促进生态繁荣。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/block-ecosys.png" alt="blockchain" /></p>

<h2 id="section-26">几条著名公链</h2>

<h3 id="btc">BTC</h3>

<p>开山鼻祖，区块链的信仰所在。比特币的出世打开了整个区块链的世界，它的存在已经成为了一种象征，寄托了大家对币/链圈的价值期望。所以比特币也成为了行业风向标，比特币行情的涨跌会直接影响其他虚拟货币的涨跌。</p>

<ul>
  <li>货币名称: BTC(比特币)</li>
  <li>共识机制: PoW</li>
  <li>创新点: 开山鼻祖，都是创新</li>
  <li>区块确认时间: 10min</li>
  <li>智能合约: 无,只有简单的加锁解锁脚本,合约语言图灵不完备</li>
</ul>

<h3 id="ethereum">Ethereum</h3>

<p>以太坊代表了区块链2.0，它将智能合约带进了现实，使得基于以太坊发放代币成为可能，直接引爆了ICO,促成了币圈第一波大浪潮。</p>

<ul>
  <li>货币名称: ETH(以太币)</li>
  <li>共识机制: PoW -&gt; PoA -&gt; PoS,以太坊在逐渐从耗能污染的PoW切换到绿色环保的PoS</li>
  <li>创新点: 第一条支持智能合约的公链</li>
  <li>区块确认时间: 15s</li>
  <li>智能合约: 有,合约语言solidity图灵完备,语法类似javascript,成熟度较高</li>
</ul>

<h3 id="eos">EOS</h3>

<p>被其粉丝冠名区块链3.0，实际上是个开历史倒车的产品，向币圈展示了项目方割韭菜的能力。</p>

<ul>
  <li>货币名称: EOS</li>
  <li>共识机制: DPoS</li>
  <li>创新点: 成功忽悠粉丝认可其独裁式治理，并冠之以民主立宪式社区治理; 另外TPS提升，我认为算不得是创新</li>
  <li>区块确认时间: 3s</li>
  <li>智能合约: 有,合约语言C++图灵完备,对开发人员要求较高</li>
</ul>

<h3 id="ont">ONT</h3>

<p>国内知名度比较高的公链</p>

<ul>
  <li>货币名称: ONT,ONG</li>
  <li>共识机制: DBFT</li>
  <li>创新点: 尝试将实体信任机制引入区块链</li>
  <li>区块确认时间: 10s</li>
  <li>智能合约: 有,合约语言python,C#,golang等,图灵完备,持续进化中</li>
</ul>

<h3 id="bch">BCH</h3>

<p>比特币现金是比特币在478599的硬分叉产物,BCH是比特币项目作为点对点数字现金的延续,它是比特币区块链帐本 (ledger) 的分叉，并具有升级版的共识规则，即允许增长和扩容。</p>

<ul>
  <li>货币名称: BCH</li>
  <li>共识机制: 比特币共识升级支持扩容</li>
  <li>创新点: 扩容算不算</li>
  <li>区块确认时间: 10s-2h</li>
  <li>智能合约: wormhole cash Wormhole虫洞协议,可以实现代币颁发,转移等等,类似于以太坊ERC20</li>
</ul>

<h1 id="section-27">进阶篇</h1>

<h2 id="utxobalance">UTXO/Balance两种模型</h2>

<p>现有的区块链基本都是基于UTXO/Balance两种模型之一构建而来，比特币采用了UTXO模型。</p>

<p>UTXO(Unspent Transaction Output)未消费交易输出，这是类似物理世界的纸币消费模型。在比特币系统中，每个交易输出就是一张比特币，这些比特币面值不一，并且无法拆分，就如同不能把100块人名币撕成两半当做两张50用一样。所以，如果用比特币买一杯2.7BTC的咖啡，你发现自己钱包里只有一张1btc和一张2btc比特币，那么只能把这两张BTC作为交易输入，这笔交易会产生两个输出，2.7btc付给商家，并且你会获得0.3btc的找零。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/utxo.png" alt="blockchain" /></p>

<p>而Balance余额模型就是以太坊为代表的账户模型，它和刷银行卡消费是一样的，以太坊系统里有个字段专门记录用户的账户余额，交易时只要对这个余额字段做加减就行了。比如你还是买一杯2.7ETH的咖啡，购买时商家会直接收到你支付的2.7eth，整个消费过程不产生找零操作。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/balance-model.jpg" alt="blockchain" /></p>

<blockquote>
  <p>P.S. 为了容易理解，举例都省略的交易手续费的描述。</p>
</blockquote>

<h2 id="section-28">分叉</h2>

<p>比特币中的软分叉和硬分叉主要指因比特币协议的突发改变而导致的兼容性的问题。比特币协议发生改变，会有两个不同版本的比特币协议在同时使，他们对其他区块的接受规则不同会导致区块链长期分叉，这两个不同的链都会被不同的网络认为是有效的。链分叉也导致网络分叉。</p>

<h3 id="section-29">软分叉</h3>

<p>软分叉的新的规则是以前旧规则的子集，所有被新版本认为是合法的区块也会被以前旧版本认为是合法的。旧版本会接受新版本创建的区块。新版本和旧版本是兼容的。</p>

<p>如果有至少51%的矿工的算力转向的新版本，那么网络自动完成软分叉：一开始旧版本创建的区块在新协议下被认为是不合法的，这时会出现一个短暂的分叉，但最终新版本的分叉会赶超旧版本的分叉成为最长链。因为在旧版本上的算力是小于新版本的。</p>

<p>但是如果小于51%的矿工算力转向新版本，那么软分叉将不会出现，因为旧版本比新版本有更多的算力支持，同时旧版本不兼容新版本。</p>

<h3 id="section-30">硬分叉</h3>

<p>旧版本不会接受新版本创建的合法区块，认为新版本的合法区块是不合法的。所以很明显硬分叉是不向前兼容。要实现硬分叉所有的用户（矿工，交易所，普通用户）都要切换的新的协议版本上。</p>

<h2 id="section-31">共识机制</h2>

<h3 id="pow">POW</h3>

<p>比特币在Block的生成过程中使用了POW机制，一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。要得到合理的Block Hash需要经过大量尝试计算，计算时间取决于机器的哈希运算速度。当某个节点提供出一个合理的Block Hash值，说明该节点确实经过了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理hash是一个概率事件。当节点拥有占全网n%的算力时，该节点即有n/100的概率找到Block Hash。</p>

<h3 id="pos">POS</h3>

<p>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 
简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息</p>

<h3 id="dpos">DPOS</h3>

<p>比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。</p>

<h3 id="pbft">PBFT</h3>

<p>PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到<code>|R|-1</code>的整数表示每一个副本。为了描述方便，假设<code>|R|=3f+1</code>，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p>

<h2 id="section-32">51%与双花</h2>

<p>51%攻击是一种攻击手段，而双花是一种攻击目的。很多文章将二者混为一谈，实际上是手段和目的混淆。</p>

<p>因为区块链(以比特币为例)，实际上使用的是一种类似”多数人认可即真理”的世俗逻辑，比特币网络中一般以上矿工达成共识，那么区块就是合法的，交易就能正常被认可。试想，如果某个组织或个人拥有比特币网络51%以上的算力，那么当他发现一笔自己”不喜欢”的交易，他就可以发动手里全部算力，强制在另一个区块开始挖矿，这就在实质上造成了网络分叉，并且因为他拥有网络大部分算力，导致最终整个网络都会放弃正常的主链，在他挖掘的分叉上继续挖矿，从而整个网络都抛弃这笔交易,分叉变成主链;这就是51%攻击，攻击者通过操纵算力篡改区块链达到自己的个人目的。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/btc-51.jpg" alt="blockchain" /></p>

<p>而双花(Double spend)是指同一笔钱被双重支付。还是以上面的例子来说明，如果这个控制51%算力的人提交一笔10BTC的交易到交易所，然后他在交易所立即将比特币提现成美元到自己的银行卡上，然后他立即将10BTC转账给自己另一个账户，并且同时操纵算力抛弃第一笔交易:即在第一笔交易的父区块上执行分叉挖矿，最终，他只是将10BTC从一个账户转移到自己另一个账户，但是交易所已经损失了10BTC等值的现金，该攻击者达到了双花的目的。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/double-spend.jpg" alt="blockchain" /></p>

<p>51%攻击的防范是一个大可提，各种共识算法也在致力于尽量降低被攻击的可能性；除了共识漏洞，更为难于预料的其实是现实算力集中，比如比特币矿池导致的事实上算力集中。</p>

<p>双花则比较好防范，目前双花都是由于低确认次数导致的，所以增大确认次数，就能极大概率保证规避双花问题。</p>

<h2 id="zcash">零知识证明与zcash</h2>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/zcash.jpeg" alt="blockchain" /></p>

<p>零知识证明指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。比如证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。</p>

<p>比如阿里巴巴怎么向四十大盗证明自己知道打开宝藏大门的咒语，并且不能直接告诉他们咒语，如童话里一样，他只需要独自念动咒语进入宝藏拿一块宝石出来给强盗看就行了。</p>

<p>零知识证明是一个技术和哲学相关的话题，很有意思，生活中可能以脑筋急转弯的形式在你身边出现过，比如<a href="https://zhuanlan.zhihu.com/p/29909734">怎么向色盲证明你能看出两个球颜色是不同的</a>。</p>

<blockquote>
  <p>如果读过《三体》的读者，很快能联想到，”宇宙安全声明”其实也是一种零知识证明。</p>
</blockquote>

<p>零知识证明的代表货币是zcash,使用zcash转账是完全匿名且不可追踪的. 具体原理这篇文章讲得很好,<a href="https://zhuanlan.zhihu.com/p/24440530">不是程序员也能看懂的ZCash零知识证明</a></p>

<h2 id="section-33">环形签名与门罗币</h2>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/monero.png" alt="blockchain" /></p>

<p>门罗币的匿名性主要是由其环形签名技术实现的。在十七世纪的时候，法国群臣向国王进谏时，为了不让国王追查到是由谁带头签名上书的，于是他们发明出了一种环形签名的方式，所有人的姓名按环形排列，自然的隐藏了签名顺序，从而做到无法追查源头。</p>

<p>2015 年，在这种签名方式的概念基础之上，数学博士 Shen Noether 发表了一篇名为《环形加密交易》的文章，为正在改进技术的门罗币奠定了环形签名算法的基础。环形签名算法与比特币一样也是使用基于哈希值的公钥+私钥模式，不同的是环形签名技术将交易发送方的公钥和另外一个公钥进行混合，然后对信息进行签署，最后再由接收者的私钥解密验证，这样一来外界就无法判断交易发起者的公钥是哪一个，从而使门罗币实现了隐藏交易发送方地址信息的功能，使外部攻击者无法看出地址之间的关联性。</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/circle-sign.jpeg" alt="blockchain" /></p>

<p>详细的技术原理参考文献<a href="http://blog.51cto.com/huihua/2170409">环形签名</a></p>

<h2 id="p2p">P2P</h2>

<p>P2P就参考我自己两篇文章吧</p>

<p><a href="http://qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/">p2p之UDP打洞</a></p>

<p><a href="http://qjpcpu.github.io/blog/2018/01/30/shen-ru-ethereumyuan-ma-p2pmo-kuai-jie-dian-fa-xian-ji-zhi/">p2p模块节点发现机制</a></p>

<h2 id="section-34">联盟链</h2>

<p>联盟链，只针对特定某个群体的成员和有限的第三方，内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定，其他接入节点可以参与交易，但不过问记账过程，其他第三方可以通过该区块链开放的API进行限定查询。为了获得更好的性能，联盟链对于共识或验证节点的配置和网络环境有一定要求。有了准入机制，可以使得交易性能更容易提高，避免由参次不齐的参与者产生的一些问题。</p>

<p>联盟链对比公链，它的准入要求高，只有授权的节点可以接入，记账节点也是严格受权限策略控制，并且由于其工作环境可信度高，并不需要使用PoW这种强证明共识算法，而且联盟链是不需要经济激励，所以大部分联盟链也不需要代币驱动矿工。所以综合起来看，我个人觉得虽然联盟链的产生是基于区块链，但它其实更应该被称为一种分布式数据库。联盟链的工作场景使用传统中心化的解决方案也许性能更优异，但存在即合理，为什么区块链以前并没有提出这种分布式解决方案? 因为区块链，它将这种一体式的解决方案打包起来，以联盟链的形式封装，所以它在企业联盟里形成了标准化的范本，这才促使它的兴起。</p>

<p>因为联盟链的这些属性，要求解决方案提供者在使用前要更加深思熟虑，是不是我真的需要一条联盟链？</p>

<p>联盟链笔者使用得不多，就简单说说我用过的.</p>

<h3 id="quorum">quorum</h3>

<p><a href="https://www.jpmorgan.co.jp/country/JP/ja/Quorum">quorum</a>是基于以太坊的联盟链解决方案。它在金融银行业相对用的多一点,在以太坊的基础上添加了许多联盟场景的功能:</p>

<ul>
  <li>取消耗能低效的PoW共识，使用了Raft/BFT协议共识算法</li>
  <li>P2P通信层修改为仅接受授权节点</li>
  <li>区块产生/验证逻辑修改,状态Patricia树修改</li>
  <li>支持私有交易</li>
  <li>去除GasPrice策略</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/quorum.jpg" alt="blockchain" /></p>

<p>我的感受是，如果对以太坊比较熟悉，迁移到quorum是比较顺畅的，但是quorum使用起来还不够舒心</p>

<ul>
  <li>对私有交易的支持比较生硬，交易权限控制无法动态变更</li>
  <li>公共合约和私有合约间相互调用，可能存在一些坑</li>
</ul>

<h3 id="hyperledger-fabric">Hyperledger Fabric</h3>

<p><a href="https://www.hyperledger.org/projects/fabric">Fabric</a>是由大名鼎鼎的linux基金会负责推进的项目，技术实力有保证，可以说是目前比较靠前的联盟链项目，然而项目目前还是处于非常早期状态，我感觉用起来还是很膈应。由于fabric目前文档比较齐全，我就不做复制粘贴了，仅聊下自己的使用感受。</p>

<ul>
  <li>运维性较差，尤其是chaincode部署得一个一个节点来，整套节点管理灵活性差</li>
  <li>生产环境共识排序依赖于kafka,BFT共识还在开发中，目前感觉kafka也是一个临时解决方案，实际使用问题不少</li>
  <li>整个体系庞杂臃肿，学习曲线陡峭,属于入门易，拔高难</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/fabric.webp" alt="blockchain" /></p>

<h1 id="section-35">参考文献</h1>

<ul>
  <li>精通比特币</li>
  <li><a href="https://blog.csdn.net/lsttoy/article/details/61624287">共识算法（POW,POS,DPOS,PBFT）介绍和心得</a></li>
  <li><a href="https://github.com/jpmorganchase/quorum/wiki/Quorum-Overview">Quorum</a></li>
  <li><a href="https://www.hyperledger.org/projects/fabric">Hyperledger Fabric</a></li>
  <li><a href="https://ont.io/wp/Ontology-technology-white-paper-ZH.pdf">ONT技术白皮书</a></li>
  <li><a href="https://eospark.com/">EOS-park</a></li>
  <li><a href="https://www.bitcoincash.org/zh-CN/">BCH</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/42300572">大话币圈丨BCH：“矿霸”吴忌寒一手操纵，币圈史上惊天背叛案</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/32613487">三分钟让你了解什么是Segwit隔离见证</a></li>
  <li><a href="https://mp.weixin.qq.com/s/-PfxSe9WPUOXMd8yrYUeZA">一种基于Bitcoin Cash的智能合约实现方案</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/24440530">不是程序员也能看懂的ZCash零知识证明</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/29909734">Zcash核心：零知识证明</a></li>
  <li><a href="https://z.cash/">z.cash</a></li>
  <li><a href="http://www.17aiot.com/blockchain/49947.html">门罗币的环形签名技术如何提高区块链的隐私性</a></li>
  <li><a href="http://blog.51cto.com/huihua/2170409">环形签名</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Rebuild Ethereum](二)区块基础结构]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/09/10/qu-kuai-ji-chu-jie-gou/"/>
    <updated>2018-09-10T06:24:59+00:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/09/10/qu-kuai-ji-chu-jie-gou</id>
    <content type="html"><![CDATA[<p>区块链是融合了密码学、分布式技术等等多个计算机领域的产物，虽然这些技术听起来都很高大上，并且不同区块链的源码看起来也都是很庞杂，令人望而生畏，但是我们回归到区块链最本身，她的基础数据结构——“链”，却是很简单的，就是一条单向链表。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">数据结构</a>    <ul>
      <li><a href="#header">Header</a></li>
      <li><a href="#transactions">Transactions</a></li>
    </ul>
  </li>
  <li><a href="#section-1">存储结构</a>    <ul>
      <li><a href="#section-2">区块头</a></li>
      <li><a href="#section-3">区块体</a></li>
      <li><a href="#section-4">交易索引</a></li>
      <li><a href="#section-5">其他</a></li>
    </ul>
  </li>
  <li><a href="#section-6">为什么是单向链表呢？</a>    <ul>
      <li><a href="#section-7">简单</a></li>
      <li><a href="#section-8">世界线</a></li>
    </ul>
  </li>
  <li><a href="#rebuild">关于rebuild</a></li>
</ul>

<h1 id="section">数据结构</h1>

<p>首先，我们来看看以太坊区块的基本结构(省略了部分非核心成员变量)</p>

<p>```go
// Block represents an entire block in the Ethereum blockchain.
type Block struct {
	header       *Header
	transactions Transactions</p>

<pre><code>// 省略其他辅助成员 } ```
</code></pre>

<p>一个区块主要由两部分组成: <code>Header</code>和 <code>Transactions</code>列表。</p>

<p><code>Transactions</code>列表就是区块的核心业务数据，无论是ETH的转账，还是某个合约调用，他们都是以一笔笔交易的形式打包到区块里,区块链被称之为分布式账本，那么这些交易就是构成账本的一笔笔流水,通过从账本第一页逐笔交易”翻阅”到最后一页,就可以还原成每个人所以的交易及账户余额。</p>

<p><code>Header</code>是区块链的索引结构，也可以看做单向链表的指向”上一个链节点”的指针，我们所谓的”翻阅”这个行为，其实就是根据这个<code>Header</code>指针遍历单向链表的过程。</p>

<p>看到这里，有数据结构基础的同学应该已经非常明白区块链的核心结构了。生产环境的区块链结果不外乎就是这条单向链表在易用性、安全性、传输、存储等多方便调和的产物。</p>

<p>下面我们还是看看以太坊的具体实现。</p>

<h2 id="header">Header</h2>

<p>```go
// Header represents a block header in the Ethereum blockchain.
type Header struct {
	ParentHash  common.Hash    <code>json:"parentHash"       gencodec:"required"</code>
	Number      *big.Int       <code>json:"number"           gencodec:"required"</code></p>

<pre><code>// 省略其他非结构性成员 } ```
</code></pre>

<p><code>header</code>的结构成员有大概15个，这里我们省略了其他和链遍历无关的成员(其他成员也很重要，包含挖矿难度、交易、共识相关参数，只是与本文无关,详细介绍可以参考<a href="http://qjpcpu.github.io/blog/2018/02/24/shen-ru-ethereumyuan-ma-cong-qu-kuai-tou-kan-gong-shi-wa-kuang/">从区块头看共识挖矿</a>).</p>

<p>结构体里面的<code>ParentHash</code>就是上一个区块的”地址”，而这里面还有一个参数<code>Number</code>就是我们常说的区块高度。单向链表的指针可以从当前最新区块回溯到创世区块，而<code>Number</code>就类似于数组序号，可以方便地直接按区块高度直接访问到某个区块。这个两个参数合起来，可以做到随机访问和顺序访问的双重满足。</p>

<blockquote>
  <p>P.S.某个区块的”地址”值由block.Hash()方法获得.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct1.jpeg" alt="eth-core-struct1" /></p>

<h2 id="transactions">Transactions</h2>

<p>区块中的<code>Transactions</code>是交易列表,交易结构就是区块链真正的业务数据。</p>

<p>```go
type Transaction struct {
	data txdata
	// 省略cache成员
}
type txdata struct {
	AccountNonce uint64          <code>json:"nonce"    gencodec:"required"</code>
	Price        *big.Int        <code>json:"gasPrice" gencodec:"required"</code>
	GasLimit     uint64          <code>json:"gas"      gencodec:"required"</code>
	Recipient    *common.Address <code>json:"to"       rlp:"nil"</code> // nil means contract creation
	Amount       *big.Int        <code>json:"value"    gencodec:"required"</code>
	Payload      []byte          <code>json:"input"    gencodec:"required"</code></p>

<pre><code>// Signature values
V *big.Int `json:"v" gencodec:"required"`
R *big.Int `json:"r" gencodec:"required"`
S *big.Int `json:"s" gencodec:"required"`

// This is only used when marshaling to JSON.
Hash *common.Hash `json:"hash" rlp:"-"` } ```
</code></pre>

<ul>
  <li><code>AccountNonce</code>是每个账户的交易自增序号,以太坊的个人交易其实是串行执行的，比如同一个账户发出<code>AccountNonce=10</code>和<code>AccountNonce=11</code>的两笔交易，即便是11先到区块链节点，最终还是需要等待10号交易打包入区块才有可能执行11号交易。</li>
  <li><code>Price</code>就是矿工的快乐源泉用户的头痛症,gasPrice。</li>
  <li><code>GasLimit</code>交易指令执行上限，这也是耳熟能详的参数了。</li>
  <li><code>Recipient</code>交易收据</li>
  <li><code>Amount</code>交易包含的eth</li>
  <li><code>Payload</code>交易体数据包</li>
  <li><code>V,R,S</code>签名数据</li>
  <li><code>Hash</code>交易hash</li>
</ul>

<h1 id="section-1">存储结构</h1>

<p>以太坊底层使用leveldb作为基础存储层，leveldb是一个高性能的k-v本地存储。那么我们主要看看它是怎么把区块数据组织起来便于CRUD的。</p>

<h2 id="section-2">区块头</h2>

<p>首先是区块头,以太坊中很多时候我们只需要获取区块头，比如轻钱包做区块查询时并不需要获取整个区块数据，仅需要header数据就足够了。</p>

<p>以太坊的区块头是这样的k-v结构:</p>

<ul>
  <li><code>key</code>:固定前缀h+区块高度大端编码+区块hash</li>
  <li><code>value</code>: rlp编码的header头数据</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct-header.jpeg" alt="eth-core-struct" /></p>

<h2 id="section-3">区块体</h2>

<p>区块体的存储和区块头非常相似:</p>

<ul>
  <li><code>key</code>:固定前缀b+区块高度大端编码+区块hash</li>
  <li><code>value</code>:rlp编码的交易列表和叔区块header体</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct-block.jpeg" alt="eth-core-struct" /></p>

<p>注意交易的数据是存在区块体中的,那么我们平时在使用以太坊浏览器的时候，可能大部分时候都是根据交易hash查询交易，如果每次都要读取区块体才知道交易性能就太低了，所以我们再看看交易存储</p>

<h2 id="section-4">交易索引</h2>

<p>为了便于查询，以太坊额外存储了交易的索引信息:</p>

<ul>
  <li><code>key</code>:固定前缀l+交易hash</li>
  <li><code>value</code>:区块hash,区块高度,交易在区块中的序号</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct-tx.jpeg" alt="eth-core-struct" /></p>

<h2 id="section-5">其他</h2>

<p>区块其他存储结构(比如收据,难度td)都以类似的k-v结构存储在leveldb中，他们共同构成了以太坊的存储结构。详细代码比较简单,可以参考<code>github.com/ethereum/go-ethereum/core/rawdb</code>和<code>github.com/ethereum/go-ethereum/ethdb</code>这两个包。</p>

<p>以太坊的基础数据结构非常简单，在看源码之前最好先熟悉一下。我之前就是忽略了这个基础，在阅读区块重组reorg的代码的时候看到<code>DeleteTxLookupEntry</code>以为是删除交易数据，导致对叔区块的理解障碍，后来补看了rawdb源码才知道，这只是删除了交易索引。</p>

<h1 id="section-6">为什么是单向链表呢？</h1>

<p>回到开头，那么为什么大多数区块链都选择了单向链表作为基础数据结构呢，我擅自揣摩可能有这样几点原因:</p>

<h2 id="section-7">简单</h2>

<p>简单既是技术抉择的原因，也是技术成型后的结果。毫无疑问，单向链表是简单的,上完第一节数据结构课的同学应该都能轻松实现一条简单链表。它简单才能易于拓展,才能在这上面方便地设计状态机，从而完成滚动记账。</p>

<h2 id="section-8">世界线</h2>

<p>这里借用一个二次元的概念,区块链的数据是有严格上下文关系的，不能摒弃历史凭空捏造数据，它天生就是交易流水串起来的一条连续的线,这和我们现实世界类似，现实世界的当前状态不过是一个一个事件串联起来的，连续演化出的结果,这就是世界线,它具有状态转移的连续性，唯一性。从这个概念的描述也能感受出，这个业务场景和单向链表也是非常匹配的,我们接触区块链很多时候都是从了解”历史不可篡改”开始，然而链表指向父节点的指针，天然承认了数据历史这一需求。</p>

<h1 id="rebuild">关于rebuild</h1>

<p>所以呢，最后我还是偷了个懒，这块的基础结构比较简单,我就不手动写Demo了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[rebuild ethereum](一) 搭建p2p网络]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/09/02/rebuild-ethereum-da-jian-p2pwang-luo/"/>
    <updated>2018-09-02T06:24:16+00:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/09/02/rebuild-ethereum-da-jian-p2pwang-luo</id>
    <content type="html"><![CDATA[<p>接触使用ethereum已经有大半年时间，一直觉得对以太坊了解无法更进一步。结合自己以前的经验, the most efficient way of learn something is to build one. 想要深入学习一样东西，最有效的方式就是自己弄脏手，从头搭建一个。</p>

<p>比如动手做linux from scratch来学习linux的五脏六腑，rebuild rails来学习rails，所以我想尝试做一个rebuild ethereum系列,来解构ethereum。</p>

<p>在该rebuild系列中，我将把视角定在构成区块链的大模块纬度,先从以太坊源码中抽离该模块,然后使用该模块编写一个可执行的程序，这样能够真实感受到这个模块的运行机制和使用方法；最终能产生”以太坊(区块链)不外乎就是这几个模块组装起来的”这种印象就达到我的目的的。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">前言</a></li>
  <li><a href="#section-1">基本诉求</a></li>
  <li><a href="#ethereum-p2pp2p">基于ethereum-p2p实现一个自定义协议的p2p网络</a>    <ul>
      <li><a href="#foo-bar">foo-bar网络</a></li>
      <li><a href="#section-2">启动网络</a></li>
    </ul>
  </li>
  <li><a href="#section-3">打开新终端窗口启动节点2</a></li>
  <li><a href="#section-4">打开新终端窗口启动节点3</a>    <ul>
      <li><a href="#section-5">观察模块运行</a></li>
    </ul>
  </li>
  <li><a href="#real-ethereum-p2p">real ethereum p2p</a></li>
  <li><a href="#section-6">本文源码</a></li>
</ul>

<h1 id="section">前言</h1>

<p>这是rebuild ethereum的第一篇,我将尝试抽离以太坊底层的p2p网络模块,搭建一个可执行的3节点的p2p网络。在这里，我不会深入介绍具体细节，其中涉及到技术细节读者可以直接查看ethereum源代码,也可以参考我之前关于以太坊p2p实现细节的几篇博客。</p>

<h1 id="section-1">基本诉求</h1>

<p>先来看看我们对于一个p2p网络模块的基本诉求:</p>

<ul>
  <li>接入网络的便利性,其实也可以表述成网络易于建立，有足够的内网穿透能力</li>
  <li>具备节点发现和维护的能力</li>
  <li>提供上层协议的拓展能力,以tcp类比,能做到在不清楚tcp的底层细节就能够开发出http协议</li>
</ul>

<h1 id="ethereum-p2pp2p">基于ethereum-p2p实现一个自定义协议的p2p网络</h1>

<h2 id="foo-bar">foo-bar网络</h2>

<p>我们实现的这个p2p网络叫foo-bar网络,她的功能很简单,接入网络后向新节点发一条<code>welcome</code>消息,然后再发一条<code>foo</code>,当节点收到后会回复一条<code>bar</code>消息.</p>

<p>定义foo-bar协议:</p>

<p>```go
type MessageType = uint64</p>

<p>// 消息类型必须从0开始递增
const (
	MT_HelloWorld MessageType = iota
	MT_FooBar
)</p>

<p>type Message string</p>

<p>func FooBarProtocol() p2p.Protocol {
	return p2p.Protocol{
		Name:    “FooBarProtocol”,
		Version: 1,
		Length:  2,  // 有几种消息类型就是几
		Run:     msgHandler,
	}
}
```</p>

<p>要注意关于协议支持的消息类型的定义，具体原因和以太坊实现细节有关,具体可以查阅<a href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/">p2p模块基础结构</a></p>

<p>实现foo-bar协议handler内容:</p>

<p>```go
func msgHandler(peer *p2p.Peer, ws p2p.MsgReadWriter) error {
	// send msg
	log.Infof(“new peer connected:%v”, peer.String())
	p2p.SendItems(ws, MT_HelloWorld, srv.NodeInfo().Name+”:welcome “+peer.Name())
	p2p.SendItems(ws, MT_FooBar, “foo”)
	for {
		msg, err := ws.ReadMsg()
		if err != nil {
			log.Warningf(“peer %s disconnected”, peer.Name())
			return err
		}</p>

<pre><code>	var myMessage [1]Message
	err = msg.Decode(&amp;myMessage)
	if err != nil {
		log.Errorf("decode msg err:%v", err)
		// handle decode error
		continue
	}

	log.Info("code:", msg.Code, "receiver at:", msg.ReceivedAt, "msg:", myMessage)
	switch myMessage[0] {
	case "foo":
		err := p2p.SendItems(ws, MT_FooBar, "bar")
		if err != nil {
			log.Errorf("send bar error:%v", err)
			return err
		}
	default:
		log.Info("recv:", myMessage)
	}
} } ```
</code></pre>

<h2 id="section-2">启动网络</h2>

<p>这里我们启动3个节点,对于测试网络结构及运转已经足够了.</p>

<p>首先编译二进制程序:</p>

<p><code>
cd ethereum-from-scratch/p2p-network &amp;&amp; go build
</code></p>

<p>启动3个节点</p>

<p>```
# 启动节点1
./start_node1.sh</p>

<h1 id="section-3">打开新终端窗口启动节点2</h1>
<p>./start_node2.sh</p>

<h1 id="section-4">打开新终端窗口启动节点3</h1>
<p>./start_node3.sh
```</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/foo-bar-node1.png" alt="foo-bar1" /></p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/foo-bar-node2.png" alt="foo-bar2" /></p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/foo-bar-node3.png" alt="foo-bar3" /></p>

<h2 id="section-5">观察模块运行</h2>

<p>从日志可以看出,ethereum的p2p模块功能非常完备，在由种子节点接入网络后,可以自动完成节点发现，并且不断刷新自身的连接表，对已经建立的节点链路发送心跳保持连接。协议数据包使用rlp格式打包,不管是消息发送还是分拆都对上层提供了极为简单的接口，所以基于次实现高级协议就非常方便了，比如以太坊whisper协议。这是向上的延展。</p>

<p>如果要向下深入，那么就可以逐个了解，rlp拆包解包，子协议拓展规则,kad网络节点发现机制,内网穿透，等等</p>

<h1 id="real-ethereum-p2p">real ethereum p2p</h1>

<p>回到真实以太坊,geth节点启动最终执行启动p2p网络的地方位于<code>github.com/ethereum/go-ethereum/node/node.go</code>文件:</p>

<p>```go
// Start create a live P2P node and starts running it.
func (n *Node) Start() error {
	n.lock.Lock()
	defer n.lock.Unlock()</p>

<pre><code>// Short circuit if the node's already running
if n.server != nil {
	return ErrNodeRunning
}
if err := n.openDataDir(); err != nil {
	return err
}

// Initialize the p2p server. This creates the node key and
// discovery databases.
n.serverConfig = n.config.P2P
n.serverConfig.PrivateKey = n.config.NodeKey()
n.serverConfig.Name = n.config.NodeName()
n.serverConfig.Logger = n.log
if n.serverConfig.StaticNodes == nil {
	n.serverConfig.StaticNodes = n.config.StaticNodes()
}
if n.serverConfig.TrustedNodes == nil {
	n.serverConfig.TrustedNodes = n.config.TrustedNodes()
}
if n.serverConfig.NodeDatabase == "" {
	n.serverConfig.NodeDatabase = n.config.NodeDB()
}
running := &amp;p2p.Server{Config: n.serverConfig}
n.log.Info("Starting peer-to-peer node", "instance", n.serverConfig.Name)

// Otherwise copy and specialize the P2P configuration
........ } ```
</code></pre>

<p>是不是和我们的demo基本一模一样.</p>

<p>具体的协议参考源码文件<code>github.com/ethereum/go-ethereum/eth/handler.go</code>子协议管理器<code>ProtocolManager</code></p>

<h1 id="section-6">本文源码</h1>

<p><a href="https://github.com/qjpcpu/ethereum-from-scratch/tree/master/p2p-network">本文源码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hyperledger-fabric服务端开发]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/07/25/hyperledger-fabricfu-wu-duan-kai-fa/"/>
    <updated>2018-07-25T06:23:59+00:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/07/25/hyperledger-fabricfu-wu-duan-kai-fa</id>
    <content type="html"><![CDATA[<p>这篇文章并不是介绍fabric智能合约怎么编写的,因为这类的文章随便在google上一搜一大把. 但反而是fabric服务端开发应该怎么做需要有人稍稍点拨一下。本文就以golang服务端为例，介绍一下fabric服务端基本做法。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#fabric-sdk-go">fabric-sdk-go</a></li>
  <li><a href="#optional---populate-vendor-directory-if-needed-by-your-downstream-vendoring-solution">Optional - populate vendor directory (if needed by your downstream vendoring solution)</a></li>
  <li><a href="#section">准备基础配置文件</a></li>
  <li><a href="#sdk">初始化sdk</a></li>
  <li><a href="#section-1">初始化通道</a></li>
  <li><a href="#chaincode">操作ChainCode</a></li>
  <li><a href="#section-2">完整示例</a></li>
  <li><a href="#section-3">其他官方示例</a></li>
</ul>

<h1 id="fabric-sdk-go">fabric-sdk-go</h1>

<p>fabric目前主要提供了<code>node</code>和<code>go</code>的SDK，我们将以<a href="https://github.com/hyperledger/fabric-sdk-go">fabric-sdk-go</a>为例搭建一个简单服务端程序。</p>

<p>首先安装fabric开发基础库:</p>

<p>```bash
go get -u github.com/hyperledger/fabric/orderer
go get -u github.com/hyperledger/fabric/peer
go get -u github.com/hyperledger/fabric-sdk-go</p>

<h1 id="optional---populate-vendor-directory-if-needed-by-your-downstream-vendoring-solution">Optional - populate vendor directory (if needed by your downstream vendoring solution)</h1>
<p># cd $GOPATH/src/github.com/hyperledger/fabric-sdk-go/
# make populate
```</p>

<h1 id="section">准备基础配置文件</h1>

<p>首先准备一份客户端连接的配置文件，配置连接orderer、peer节点，证书路径等信息:</p>

<p>```yaml config_e2e.yaml
#
# Schema version of the content. Used by the SDK to apply the corresponding parsing rules.
#
version: 1.0.0</p>

<p>#
# The client section used by GO SDK.
#
client:</p>

<p># Which organization does this application instance belong to? The value must be the name of an org
  # defined under “organizations”
  organization: org1</p>

<p>logging:
    level: info</p>

<p># Root of the MSP directories with keys and certs.
  cryptoconfig:
    path: /home/ubuntu/.local/src/playfabric/first-network/crypto-config</p>

<p># Some SDKs support pluggable KV stores, the properties under “credentialStore”
  # are implementation specific
  credentialStore:
    # [Optional]. Used by user store. Not needed if all credentials are embedded in configuration
    # and enrollments are performed elswhere.
    path: “/tmp/state-store”</p>

<pre><code># [Optional]. Specific to the CryptoSuite implementation used by GO SDK. Software-based implementations
# requiring a key store. PKCS#11 based implementations does not.
cryptoStore:
  # Specific to the underlying KeyValueStore that backs the crypto key store.
  path: /tmp/msp
</code></pre>

<p># BCCSP config for the client. Used by GO SDK.
  BCCSP:
    security:
     enabled: true
     default:
      provider: “SW”
     hashAlgorithm: “SHA2”
     softVerify: true
     level: 256</p>

<p>tlsCerts:
    # [Optional]. Use system certificate pool when connecting to peers, orderers (for negotiating TLS) Default: false
    systemCertPool: false</p>

<p>channels:
  # name of the channel
  mychannel:
    # Required. list of peers from participating orgs
    peers:
      peer0.org1.example.com:
        # [Optional]. will this peer be sent transaction proposals for endorsement? The peer must
        # have the chaincode installed. The app can also use this property to decide which peers
        # to send the chaincode install request. Default: true
        endorsingPeer: true</p>

<pre><code>    # [Optional]. will this peer be sent query proposals? The peer must have the chaincode
    # installed. The app can also use this property to decide which peers to send the
    # chaincode install request. Default: true
    chaincodeQuery: true

    # [Optional]. will this peer be sent query proposals that do not require chaincodes, like
    # queryBlock(), queryTransaction(), etc. Default: true
    ledgerQuery: true

    # [Optional]. will this peer be the target of the SDK's listener registration? All peers can
    # produce events but the app typically only needs to connect to one to listen to events.
    # Default: true
    eventSource: true

# [Optional]. The application can use these options to perform channel operations like retrieving channel
# config etc.
policies:
  #[Optional] options for retrieving channel configuration blocks
  queryChannelConfig:
    #[Optional] min number of success responses (from targets/peers)
    minResponses: 1
    #[Optional] channel config will be retrieved for these number of random targets
    maxTargets: 1
    #[Optional] retry options for query config block
    retryOpts:
      #[Optional] number of retry attempts
      attempts: 5
      #[Optional] the back off interval for the first retry attempt
      initialBackoff: 500ms
      #[Optional] the maximum back off interval for any retry attempt
      maxBackoff: 5s
      #[Optional] he factor by which the initial back off period is exponentially incremented
      backoffFactor: 2.0
</code></pre>

<p>#
# list of participating organizations in this network
#
organizations:
  org1:
    mspid: Org1MSP</p>

<pre><code># This org's MSP store (absolute path or relative to client.cryptoconfig)
cryptoPath:  peerOrganizations/org1.example.com/users/{username}@org1.example.com/msp

peers:
  - peer0.org1.example.com
  - peer1.org1.example.com

# [Optional]. Certificate Authorities issue certificates for identification purposes in a Fabric based
# network. Typically certificates provisioning is done in a separate process outside of the
# runtime network. Fabric-CA is a special certificate authority that provides a REST APIs for
# dynamic certificate management (enroll, revoke, re-enroll). The following section is only for
# Fabric-CA servers.
certificateAuthorities:
  - ca.org1.example.com
</code></pre>

<p># the profile will contain public information about organizations other than the one it belongs to.
  # These are necessary information to make transaction lifecycles work, including MSP IDs and
  # peers with a public URL to send transaction proposals. The file will not contain private
  # information reserved for members of the organization, such as admin key and certificate,
  # fabric-ca registrar enroll ID and secret, etc.
  org2:
    mspid: Org2MSP</p>

<pre><code># This org's MSP store (absolute path or relative to client.cryptoconfig)
cryptoPath:  peerOrganizations/org2.example.com/users/{username}@org2.example.com/msp

peers:
  - peer0.org2.example.com

certificateAuthorities:
  - ca.org2.example.com
</code></pre>

<p># Orderer Org name
  ordererorg:
      # Membership Service Provider ID for this organization
      mspID: OrdererMSP</p>

<pre><code>  # Needed to load users crypto keys and certs for this org (absolute path or relative to global crypto path, DEV mode)
  cryptoPath: ordererOrganizations/example.com/users/{username}@example.com/msp
</code></pre>

<p>#
# List of orderers to send transaction and channel create/update requests to. For the time
# being only one orderer is needed. If more than one is defined, which one get used by the
# SDK is implementation specific. Consult each SDK’s documentation for its handling of orderers.
#
orderers:
  orderer.example.com:
    url: orderer.example.com:7050</p>

<pre><code># these are standard properties defined by the gRPC library
# they will be passed in as-is to gRPC client constructor
grpcOptions:
  ssl-target-name-override: orderer.example.com
  # These parameters should be set in coordination with the keepalive policy on the server,
  # as incompatible settings can result in closing of connection.
  # When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled
  keep-alive-time: 0s
  keep-alive-timeout: 20s
  keep-alive-permit: false
  fail-fast: false
  # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
  allow-insecure: false

tlsCACerts:
  # Certificate location absolute path
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem
</code></pre>

<p>#
# List of peers to send various requests to, including endorsement, query
# and event listener registration.
#
peers:
  peer0.org1.example.com:
    # this URL is used to send endorsement and query requests
    url: peer0.org1.example.com:7051
    # eventUrl is only needed when using eventhub (default is delivery service)
    eventUrl: peer0.org1.example.com:7053</p>

<pre><code>grpcOptions:
  ssl-target-name-override: peer0.org1.example.com
  # These parameters should be set in coordination with the keepalive policy on the server,
  # as incompatible settings can result in closing of connection.
  # When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled
  keep-alive-time: 0s
  keep-alive-timeout: 20s
  keep-alive-permit: false
  fail-fast: false
  # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
  allow-insecure: false

tlsCACerts:
  # Certificate location absolute path
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/peerOrganizations/org1.example.com/tlsca/tlsca.org1.example.com-cert.pem
</code></pre>

<p>peer1.org1.example.com:
    # this URL is used to send endorsement and query requests
    url: peer1.org1.example.com:7151
    # eventUrl is only needed when using eventhub (default is delivery service)
    eventUrl: peer1.org1.example.com:7153</p>

<pre><code>grpcOptions:
  ssl-target-name-override: peer1.org1.example.com
  # These parameters should be set in coordination with the keepalive policy on the server,
  # as incompatible settings can result in closing of connection.
  # When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled
  keep-alive-time: 0s
  keep-alive-timeout: 20s
  keep-alive-permit: false
  fail-fast: false
  # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
  allow-insecure: false

tlsCACerts:
  # Certificate location absolute path
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/peerOrganizations/org1.example.com/tlsca/tlsca.org1.example.com-cert.pem
</code></pre>

<p>peer0.org2.example.com:
    url: peer0.org2.example.com:8051
    # eventUrl is only needed when using eventhub (default is delivery service)
    eventUrl: peer0.org2.example.com:8053
    grpcOptions:
      ssl-target-name-override: peer0.org2.example.com
      # These parameters should be set in coordination with the keepalive policy on the server,
      # as incompatible settings can result in closing of connection.
      # When duration of the ‘keep-alive-time’ is set to 0 or less the keep alive client parameters are disabled
      keep-alive-time: 0s
      keep-alive-timeout: 20s
      keep-alive-permit: false
      fail-fast: false
      # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
      allow-insecure: false</p>

<pre><code>tlsCACerts:
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/peerOrganizations/org2.example.com/tlsca/tlsca.org2.example.com-cert.pem ```
</code></pre>

<h1 id="sdk">初始化sdk</h1>

<p>使用<code>github.com/hyperledger/fabric-sdk-go/pkg/core/config</code>包读取并解析配置文件,加载完成后即可初始化sdk</p>

<p><code>go
configPath := os.Getenv("GOPATH") + "/src/playfabric/config_e2e.yaml"
configOpt := config.FromFile(configPath)
sdk, err := fabsdk.New(configOpt)
if err != nil {
	fmt.Println(err)
	os.Exit(1)
}
defer sdk.Close()
</code></p>

<h1 id="section-1">初始化通道</h1>

<p>初始化channelContext及channel,至此初始化工作完成，可以操作chain code或者查询账本。</p>

<p><code>go
//prepare channel client context using client context
clientChannelContext := sdk.ChannelContext("mychannel", fabsdk.WithUser("User1"), fabsdk.WithOrg(orgName))
// Channel client is used to query and execute transactions (Org1 is default org)
client, err := channel.New(clientChannelContext)
if err != nil {
	fmt.Printf("Failed to create new channel client: %s", err)
	os.Exit(1)
}
</code></p>

<h1 id="chaincode">操作ChainCode</h1>

<p>以官方example02的chain code（代币转移合约）为例:</p>

<p><code>go
// a =&gt; b转账2个代币
func executeCC(client *channel.Client) error {
	res, err := client.Execute(channel.Request{ChaincodeID: ccID, Fcn: "invoke", Args: makeArgs("a", "b", "2")},
		channel.WithRetry(retry.DefaultChannelOpts))
	fmt.Println("exe tx:", res.TransactionID)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return err
}
// 查询某个账户代币余额
func queryCC(client *channel.Client, who string) []byte {
	response, err := client.Query(channel.Request{ChaincodeID: ccID, Fcn: "query", Args: makeArgs(who)},
		channel.WithRetry(retry.DefaultChannelOpts),
		channel.WithTargetEndpoints(),
	)
	fmt.Println("query tx:", response.TransactionID)
	if err != nil {
		fmt.Printf("Failed to query funds: %s", err)
		os.Exit(1)
	}
	return response.Payload
}
</code></p>

<h1 id="section-2">完整示例</h1>

<p>完整示例很简单，包含代币转让及查询、底层账本查询（对应fabric1.1，BYFN示例网络）</p>

<p>```go
package main</p>

<p>import (
	“encoding/hex”
	“fmt”
	“github.com/hyperledger/fabric-sdk-go/pkg/client/ledger”
	“github.com/hyperledger/fabric-sdk-go/third_party/github.com/hyperledger/fabric/protos/common”
	“github.com/hyperledger/fabric/common/util”
	“github.com/hyperledger/fabric-sdk-go/pkg/common/errors/retry”
	“github.com/hyperledger/fabric-sdk-go/pkg/client/channel”
	“github.com/hyperledger/fabric-sdk-go/pkg/core/config”
	“github.com/hyperledger/fabric-sdk-go/pkg/fabsdk”
	“os”
)</p>

<p>const (
	channelID      = “mychannel”
	orgName        = “Org1”
	orgAdmin       = “Admin”
	ordererOrgName = “OrdererOrg”
	ccID           = “mycc”
)</p>

<p>func queryLedgerExample() {
	configPath := os.Getenv(“GOPATH”) + “/src/playfabric/config_e2e.yaml”
	configOpt := config.FromFile(configPath)
	sdk, err := fabsdk.New(configOpt)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	defer sdk.Close()
	//prepare channel client context using client context
	clientChannelContext := sdk.ChannelContext(channelID, fabsdk.WithUser(“User1”), fabsdk.WithOrg(orgName))
	// Channel client is used to query and execute transactions (Org1 is default org)
	client, err := ledger.New(clientChannelContext)
	if err != nil {
		fmt.Printf(“Failed to create new channel client: %s”, err)
		os.Exit(1)
	}
	ledgerInfo, err := client.QueryInfo()
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	printBCI(ledgerInfo.BCI)
	block, err := client.QueryBlock(ledgerInfo.BCI.GetHeight() - 1)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	printBlock(block)
	// txid := “63abb9a2ae8e7f3f689498f4ccedef6001ab7902ba9dfe69e2c270a4f7ff1d4d”
	// tx, err := client.QueryTransaction(fab.TransactionID(txid))
	// if err != nil {
	// 	fmt.Println(err)
	// 	os.Exit(1)
	// }
	// fmt.Println(“Tx:”, txid, “payload:”, hex.EncodeToString(tx.GetTransactionEnvelope().GetPayload()))
}</p>

<p>func printBCI(blk *common.BlockchainInfo) {
	fmt.Println(“block height:”, blk.GetHeight())
	fmt.Println(“block hash:”, hex.EncodeToString(blk.GetCurrentBlockHash()))
	fmt.Println(“block prevhash:”, hex.EncodeToString(blk.GetPreviousBlockHash()))
	fmt.Println(“=====================================================”)
}</p>

<p>func printBlock(blk *common.Block) {
	fmt.Printf(“BlockNO:%v\n”, blk.GetHeader().GetNumber())
	fmt.Println(“prevhash:”, hex.EncodeToString(blk.GetHeader().GetPreviousHash()))
	fmt.Println(“hash:”, hex.EncodeToString(util.ComputeSHA256(util.ConcatenateBytes(blk.GetData().GetData()…))))
	fmt.Println(“=====================================================”)
}</p>

<p>func main() {
	configPath := os.Getenv(“GOPATH”) + “/src/playfabric/config_e2e.yaml”
	configOpt := config.FromFile(configPath)
	sdk, err := fabsdk.New(configOpt)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	defer sdk.Close()
	//prepare channel client context using client context
	clientChannelContext := sdk.ChannelContext(channelID, fabsdk.WithUser(“User1”), fabsdk.WithOrg(orgName))
	// Channel client is used to query and execute transactions (Org1 is default org)
	client, err := channel.New(clientChannelContext)
	if err != nil {
		fmt.Printf(“Failed to create new channel client: %s”, err)
		os.Exit(1)
	}
	fmt.Println(“a”, string(queryCC(client, “a”)))
	fmt.Println(“b”, string(queryCC(client, “b”)))</p>

<pre><code>executeCC(client)

fmt.Println("a", string(queryCC(client, "a")))
fmt.Println("b", string(queryCC(client, "b"))) }
</code></pre>

<p>func executeCC(client *channel.Client) error {
	res, err := client.Execute(channel.Request{ChaincodeID: ccID, Fcn: “invoke”, Args: makeArgs(“a”, “b”, “2”)},
		channel.WithRetry(retry.DefaultChannelOpts))
	fmt.Println(“exe tx:”, res.TransactionID)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return err
}</p>

<p>func queryCC(client *channel.Client, who string) []byte {
	response, err := client.Query(channel.Request{ChaincodeID: ccID, Fcn: “query”, Args: makeArgs(who)},
		channel.WithRetry(retry.DefaultChannelOpts),
		channel.WithTargetEndpoints(),
	)
	fmt.Println(“query tx:”, response.TransactionID)
	if err != nil {
		fmt.Printf(“Failed to query funds: %s”, err)
		os.Exit(1)
	}
	return response.Payload
}</p>

<p>func makeArgs(args …string) [][]byte {
	var ccargs [][]byte
	for _, arg := range args {
		ccargs = append(ccargs, []byte(arg))
	}
	return ccargs
}
```</p>

<h1 id="section-3">其他官方示例</h1>

<ul>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/e2e/end_to_end.go">E2E Test</a>: Basic example that uses SDK to query and execute transaction</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/pkg/client/ledger/ledger_queries_test.go">Ledger Query Test</a>: Basic example that uses SDK to query a channel’s underlying ledger</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/e2e/orgs/multiple_orgs_test.go">Multi Org Test</a>: An example that has multiple organisations involved in transaction</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/pkg/fabsdk/provider/sdk_provider_test.go">Dynamic Endorser Selection</a>: An example that uses dynamic endorser selection (based on chaincode policy)</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/e2e/pkcs11/e2e_test.go">E2E PKCS11 Test</a>: E2E Test using a PKCS11 crypto suite and configuration</li>
  <li><a href="https://github.com/securekey/fabric-examples/tree/master/fabric-cli/">CLI</a>: An example CLI for Fabric built with the Go SDK.</li>
</ul>
]]></content>
  </entry>
  
</feed>
