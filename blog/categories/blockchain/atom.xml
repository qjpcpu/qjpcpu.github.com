<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: blockchain | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/blockchain/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2018-09-17T15:48:48+08:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Rebuild Ethereum](二)区块基础结构]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/09/10/qu-kuai-ji-chu-jie-gou/"/>
    <updated>2018-09-10T14:24:59+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/09/10/qu-kuai-ji-chu-jie-gou</id>
    <content type="html"><![CDATA[<p>区块链是融合了密码学、分布式技术等等多个计算机领域的产物，虽然这些技术听起来都很高大上，并且不同区块链的源码看起来也都是很庞杂，令人望而生畏，但是我们回归到区块链最本身，她的基础数据结构——“链”，却是很简单的，就是一条单向链表。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">数据结构</a>    <ul>
      <li><a href="#header">Header</a></li>
      <li><a href="#transactions">Transactions</a></li>
    </ul>
  </li>
  <li><a href="#section-1">存储结构</a>    <ul>
      <li><a href="#section-2">区块头</a></li>
      <li><a href="#section-3">区块体</a></li>
      <li><a href="#section-4">交易索引</a></li>
      <li><a href="#section-5">其他</a></li>
    </ul>
  </li>
  <li><a href="#section-6">为什么是单向链表呢？</a>    <ul>
      <li><a href="#section-7">简单</a></li>
      <li><a href="#section-8">世界线</a></li>
    </ul>
  </li>
  <li><a href="#rebuild">关于rebuild</a></li>
</ul>

<h1 id="section">数据结构</h1>

<p>首先，我们来看看以太坊区块的基本结构(省略了部分非核心成员变量)</p>

<p>```go
// Block represents an entire block in the Ethereum blockchain.
type Block struct {
	header       *Header
	transactions Transactions</p>

<pre><code>// 省略其他辅助成员 } ```
</code></pre>

<p>一个区块主要由两部分组成: <code>Header</code>和 <code>Transactions</code>列表。</p>

<p><code>Transactions</code>列表就是区块的核心业务数据，无论是ETH的转账，还是某个合约调用，他们都是以一笔笔交易的形式打包到区块里,区块链被称之为分布式账本，那么这些交易就是构成账本的一笔笔流水,通过从账本第一页逐笔交易”翻阅”到最后一页,就可以还原成每个人所以的交易及账户余额。</p>

<p><code>Header</code>是区块链的索引结构，也可以看做单向链表的指向”上一个链节点”的指针，我们所谓的”翻阅”这个行为，其实就是根据这个<code>Header</code>指针遍历单向链表的过程。</p>

<p>看到这里，有数据结构基础的同学应该已经非常明白区块链的核心结构了。生产环境的区块链结果不外乎就是这条单向链表在易用性、安全性、传输、存储等多方便调和的产物。</p>

<p>下面我们还是看看以太坊的具体实现。</p>

<h2 id="header">Header</h2>

<p>```go
// Header represents a block header in the Ethereum blockchain.
type Header struct {
	ParentHash  common.Hash    <code>json:"parentHash"       gencodec:"required"</code>
	Number      *big.Int       <code>json:"number"           gencodec:"required"</code></p>

<pre><code>// 省略其他非结构性成员 } ```
</code></pre>

<p><code>header</code>的结构成员有大概15个，这里我们省略了其他和链遍历无关的成员(其他成员也很重要，包含挖矿难度、交易、共识相关参数，只是与本文无关,详细介绍可以参考<a href="http://qjpcpu.github.io/blog/2018/02/24/shen-ru-ethereumyuan-ma-cong-qu-kuai-tou-kan-gong-shi-wa-kuang/">从区块头看共识挖矿</a>).</p>

<p>结构体里面的<code>ParentHash</code>就是上一个区块的”地址”，而这里面还有一个参数<code>Number</code>就是我们常说的区块高度。单向链表的指针可以从当前最新区块回溯到创世区块，而<code>Number</code>就类似于数组序号，可以方便地直接按区块高度直接访问到某个区块。这个两个参数合起来，可以做到随机访问和顺序访问的双重满足。</p>

<blockquote>
  <p>P.S.某个区块的”地址”值由block.Hash()方法获得.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct1.jpeg" alt="eth-core-struct1" /></p>

<h2 id="transactions">Transactions</h2>

<p>区块中的<code>Transactions</code>是交易列表,交易结构就是区块链真正的业务数据。</p>

<p>```go
type Transaction struct {
	data txdata
	// 省略cache成员
}
type txdata struct {
	AccountNonce uint64          <code>json:"nonce"    gencodec:"required"</code>
	Price        *big.Int        <code>json:"gasPrice" gencodec:"required"</code>
	GasLimit     uint64          <code>json:"gas"      gencodec:"required"</code>
	Recipient    *common.Address <code>json:"to"       rlp:"nil"</code> // nil means contract creation
	Amount       *big.Int        <code>json:"value"    gencodec:"required"</code>
	Payload      []byte          <code>json:"input"    gencodec:"required"</code></p>

<pre><code>// Signature values
V *big.Int `json:"v" gencodec:"required"`
R *big.Int `json:"r" gencodec:"required"`
S *big.Int `json:"s" gencodec:"required"`

// This is only used when marshaling to JSON.
Hash *common.Hash `json:"hash" rlp:"-"` } ```
</code></pre>

<ul>
  <li><code>AccountNonce</code>是每个账户的交易自增序号,以太坊的个人交易其实是串行执行的，比如同一个账户发出<code>AccountNonce=10</code>和<code>AccountNonce=11</code>的两笔交易，即便是11先到区块链节点，最终还是需要等待10号交易打包入区块才有可能执行11号交易。</li>
  <li><code>Price</code>就是矿工的快乐源泉用户的头痛症,gasPrice。</li>
  <li><code>GasLimit</code>交易指令执行上限，这也是耳熟能详的参数了。</li>
  <li><code>Recipient</code>交易收据</li>
  <li><code>Amount</code>交易包含的eth</li>
  <li><code>Payload</code>交易体数据包</li>
  <li><code>V,R,S</code>签名数据</li>
  <li><code>Hash</code>交易hash</li>
</ul>

<h1 id="section-1">存储结构</h1>

<p>以太坊底层使用leveldb作为基础存储层，leveldb是一个高性能的k-v本地存储。那么我们主要看看它是怎么把区块数据组织起来便于CRUD的。</p>

<h2 id="section-2">区块头</h2>

<p>首先是区块头,以太坊中很多时候我们只需要获取区块头，比如轻钱包做区块查询时并不需要获取整个区块数据，仅需要header数据就足够了。</p>

<p>以太坊的区块头是这样的k-v结构:</p>

<ul>
  <li><code>key</code>:固定前缀h+区块高度大端编码+区块hash</li>
  <li><code>value</code>: rlp编码的header头数据</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct-header.jpeg" alt="eth-core-struct" /></p>

<h2 id="section-3">区块体</h2>

<p>区块体的存储和区块头非常相似:</p>

<ul>
  <li><code>key</code>:固定前缀b+区块高度大端编码+区块hash</li>
  <li><code>value</code>:rlp编码的交易列表和叔区块header体</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct-block.jpeg" alt="eth-core-struct" /></p>

<p>注意交易的数据是存在区块体中的,那么我们平时在使用以太坊浏览器的时候，可能大部分时候都是根据交易hash查询交易，如果每次都要读取区块体才知道交易性能就太低了，所以我们再看看交易存储</p>

<h2 id="section-4">交易索引</h2>

<p>为了便于查询，以太坊额外存储了交易的索引信息:</p>

<ul>
  <li><code>key</code>:固定前缀l+交易hash</li>
  <li><code>value</code>:区块hash,区块高度,交易在区块中的序号</li>
</ul>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/eth-core-struct-tx.jpeg" alt="eth-core-struct" /></p>

<h2 id="section-5">其他</h2>

<p>区块其他存储结构(比如收据,难度td)都以类似的k-v结构存储在leveldb中，他们共同构成了以太坊的存储结构。详细代码比较简单,可以参考<code>github.com/ethereum/go-ethereum/core/rawdb</code>和<code>github.com/ethereum/go-ethereum/ethdb</code>这两个包。</p>

<p>以太坊的基础数据结构非常简单，在看源码之前最好先熟悉一下。我之前就是忽略了这个基础，在阅读区块重组reorg的代码的时候看到<code>DeleteTxLookupEntry</code>以为是删除交易数据，导致对叔区块的理解障碍，后来补看了rawdb源码才知道，这只是删除了交易索引。</p>

<h1 id="section-6">为什么是单向链表呢？</h1>

<p>回到开头，那么为什么大多数区块链都选择了单向链表作为基础数据结构呢，我擅自揣摩可能有这样几点原因:</p>

<h2 id="section-7">简单</h2>

<p>简单既是技术抉择的原因，也是技术成型后的结果。毫无疑问，单向链表是简单的,上完第一节数据结构课的同学应该都能轻松实现一条简单链表。它简单才能易于拓展,才能在这上面方便地设计状态机，从而完成滚动记账。</p>

<h2 id="section-8">世界线</h2>

<p>这里借用一个二次元的概念,区块链的数据是有严格上下文关系的，不能摒弃历史凭空捏造数据，它天生就是交易流水串起来的一条连续的线,这和我们现实世界类似，现实世界的当前状态不过是一个一个事件串联起来的，连续演化出的结果,这就是世界线,它具有状态转移的连续性，唯一性。从这个概念的描述也能感受出，这个业务场景和单向链表也是非常匹配的,我们接触区块链很多时候都是从了解”历史不可篡改”开始，然而链表指向父节点的指针，天然承认了数据历史这一需求。</p>

<h1 id="rebuild">关于rebuild</h1>

<p>所以呢，最后我还是偷了个懒，这块的基础结构比较简单,我就不手动写Demo了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[rebuild ethereum](一) 搭建p2p网络]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/09/02/rebuild-ethereum-da-jian-p2pwang-luo/"/>
    <updated>2018-09-02T14:24:16+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/09/02/rebuild-ethereum-da-jian-p2pwang-luo</id>
    <content type="html"><![CDATA[<p>接触使用ethereum已经有大半年时间，一直觉得对以太坊了解无法更进一步。结合自己以前的经验, the most efficient way of learn something is to build one. 想要深入学习一样东西，最有效的方式就是自己弄脏手，从头搭建一个。</p>

<p>比如动手做linux from scratch来学习linux的五脏六腑，rebuild rails来学习rails，所以我想尝试做一个rebuild ethereum系列,来解构ethereum。</p>

<p>在该rebuild系列中，我将把视角定在构成区块链的大模块纬度,先从以太坊源码中抽离该模块,然后使用该模块编写一个可执行的程序，这样能够真实感受到这个模块的运行机制和使用方法；最终能产生”以太坊(区块链)不外乎就是这几个模块组装起来的”这种印象就达到我的目的的。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">前言</a></li>
  <li><a href="#section-1">基本诉求</a></li>
  <li><a href="#ethereum-p2pp2p">基于ethereum-p2p实现一个自定义协议的p2p网络</a>    <ul>
      <li><a href="#foo-bar">foo-bar网络</a></li>
      <li><a href="#section-2">启动网络</a></li>
    </ul>
  </li>
  <li><a href="#section-3">打开新终端窗口启动节点2</a></li>
  <li><a href="#section-4">打开新终端窗口启动节点3</a>    <ul>
      <li><a href="#section-5">观察模块运行</a></li>
    </ul>
  </li>
  <li><a href="#real-ethereum-p2p">real ethereum p2p</a></li>
  <li><a href="#section-6">本文源码</a></li>
</ul>

<h1 id="section">前言</h1>

<p>这是rebuild ethereum的第一篇,我将尝试抽离以太坊底层的p2p网络模块,搭建一个可执行的3节点的p2p网络。在这里，我不会深入介绍具体细节，其中涉及到技术细节读者可以直接查看ethereum源代码,也可以参考我之前关于以太坊p2p实现细节的几篇博客。</p>

<h1 id="section-1">基本诉求</h1>

<p>先来看看我们对于一个p2p网络模块的基本诉求:</p>

<ul>
  <li>接入网络的便利性,其实也可以表述成网络易于建立，有足够的内网穿透能力</li>
  <li>具备节点发现和维护的能力</li>
  <li>提供上层协议的拓展能力,以tcp类比,能做到在不清楚tcp的底层细节就能够开发出http协议</li>
</ul>

<h1 id="ethereum-p2pp2p">基于ethereum-p2p实现一个自定义协议的p2p网络</h1>

<h2 id="foo-bar">foo-bar网络</h2>

<p>我们实现的这个p2p网络叫foo-bar网络,她的功能很简单,接入网络后向新节点发一条<code>welcome</code>消息,然后再发一条<code>foo</code>,当节点收到后会回复一条<code>bar</code>消息.</p>

<p>定义foo-bar协议:</p>

<p>```go
type MessageType = uint64</p>

<p>// 消息类型必须从0开始递增
const (
	MT_HelloWorld MessageType = iota
	MT_FooBar
)</p>

<p>type Message string</p>

<p>func FooBarProtocol() p2p.Protocol {
	return p2p.Protocol{
		Name:    “FooBarProtocol”,
		Version: 1,
		Length:  2,  // 有几种消息类型就是几
		Run:     msgHandler,
	}
}
```</p>

<p>要注意关于协议支持的消息类型的定义，具体原因和以太坊实现细节有关,具体可以查阅<a href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/">p2p模块基础结构</a></p>

<p>实现foo-bar协议handler内容:</p>

<p>```go
func msgHandler(peer *p2p.Peer, ws p2p.MsgReadWriter) error {
	// send msg
	log.Infof(“new peer connected:%v”, peer.String())
	p2p.SendItems(ws, MT_HelloWorld, srv.NodeInfo().Name+”:welcome “+peer.Name())
	p2p.SendItems(ws, MT_FooBar, “foo”)
	for {
		msg, err := ws.ReadMsg()
		if err != nil {
			log.Warningf(“peer %s disconnected”, peer.Name())
			return err
		}</p>

<pre><code>	var myMessage [1]Message
	err = msg.Decode(&amp;myMessage)
	if err != nil {
		log.Errorf("decode msg err:%v", err)
		// handle decode error
		continue
	}

	log.Info("code:", msg.Code, "receiver at:", msg.ReceivedAt, "msg:", myMessage)
	switch myMessage[0] {
	case "foo":
		err := p2p.SendItems(ws, MT_FooBar, "bar")
		if err != nil {
			log.Errorf("send bar error:%v", err)
			return err
		}
	default:
		log.Info("recv:", myMessage)
	}
} } ```
</code></pre>

<h2 id="section-2">启动网络</h2>

<p>这里我们启动3个节点,对于测试网络结构及运转已经足够了.</p>

<p>首先编译二进制程序:</p>

<p><code>
cd ethereum-from-scratch/p2p-network &amp;&amp; go build
</code></p>

<p>启动3个节点</p>

<p>```
# 启动节点1
./start_node1.sh</p>

<h1 id="section-3">打开新终端窗口启动节点2</h1>
<p>./start_node2.sh</p>

<h1 id="section-4">打开新终端窗口启动节点3</h1>
<p>./start_node3.sh
```</p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/foo-bar-node1.png" alt="foo-bar1" /></p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/foo-bar-node2.png" alt="foo-bar2" /></p>

<p><img src="https://raw.githubusercontent.com/qjpcpu/qjpcpu.github.com/master/images/foo-bar-node3.png" alt="foo-bar3" /></p>

<h2 id="section-5">观察模块运行</h2>

<p>从日志可以看出,ethereum的p2p模块功能非常完备，在由种子节点接入网络后,可以自动完成节点发现，并且不断刷新自身的连接表，对已经建立的节点链路发送心跳保持连接。协议数据包使用rlp格式打包,不管是消息发送还是分拆都对上层提供了极为简单的接口，所以基于次实现高级协议就非常方便了，比如以太坊whisper协议。这是向上的延展。</p>

<p>如果要向下深入，那么就可以逐个了解，rlp拆包解包，子协议拓展规则,kad网络节点发现机制,内网穿透，等等</p>

<h1 id="real-ethereum-p2p">real ethereum p2p</h1>

<p>回到真实以太坊,geth节点启动最终执行启动p2p网络的地方位于<code>github.com/ethereum/go-ethereum/node/node.go</code>文件:</p>

<p>```go
// Start create a live P2P node and starts running it.
func (n *Node) Start() error {
	n.lock.Lock()
	defer n.lock.Unlock()</p>

<pre><code>// Short circuit if the node's already running
if n.server != nil {
	return ErrNodeRunning
}
if err := n.openDataDir(); err != nil {
	return err
}

// Initialize the p2p server. This creates the node key and
// discovery databases.
n.serverConfig = n.config.P2P
n.serverConfig.PrivateKey = n.config.NodeKey()
n.serverConfig.Name = n.config.NodeName()
n.serverConfig.Logger = n.log
if n.serverConfig.StaticNodes == nil {
	n.serverConfig.StaticNodes = n.config.StaticNodes()
}
if n.serverConfig.TrustedNodes == nil {
	n.serverConfig.TrustedNodes = n.config.TrustedNodes()
}
if n.serverConfig.NodeDatabase == "" {
	n.serverConfig.NodeDatabase = n.config.NodeDB()
}
running := &amp;p2p.Server{Config: n.serverConfig}
n.log.Info("Starting peer-to-peer node", "instance", n.serverConfig.Name)

// Otherwise copy and specialize the P2P configuration
........ } ```
</code></pre>

<p>是不是和我们的demo基本一模一样.</p>

<p>具体的协议参考源码文件<code>github.com/ethereum/go-ethereum/eth/handler.go</code>子协议管理器<code>ProtocolManager</code></p>

<h1 id="section-6">本文源码</h1>

<p><a href="https://github.com/qjpcpu/ethereum-from-scratch/tree/master/p2p-network">本文源码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hyperledger-fabric服务端开发]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/07/25/hyperledger-fabricfu-wu-duan-kai-fa/"/>
    <updated>2018-07-25T14:23:59+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/07/25/hyperledger-fabricfu-wu-duan-kai-fa</id>
    <content type="html"><![CDATA[<p>这篇文章并不是介绍fabric智能合约怎么编写的,因为这类的文章随便在google上一搜一大把. 但反而是fabric服务端开发应该怎么做需要有人稍稍点拨一下。本文就以golang服务端为例，介绍一下fabric服务端基本做法。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#fabric-sdk-go">fabric-sdk-go</a></li>
  <li><a href="#optional---populate-vendor-directory-if-needed-by-your-downstream-vendoring-solution">Optional - populate vendor directory (if needed by your downstream vendoring solution)</a></li>
  <li><a href="#section">准备基础配置文件</a></li>
  <li><a href="#sdk">初始化sdk</a></li>
  <li><a href="#section-1">初始化通道</a></li>
  <li><a href="#chaincode">操作ChainCode</a></li>
  <li><a href="#section-2">完整示例</a></li>
  <li><a href="#section-3">其他官方示例</a></li>
</ul>

<h1 id="fabric-sdk-go">fabric-sdk-go</h1>

<p>fabric目前主要提供了<code>node</code>和<code>go</code>的SDK，我们将以<a href="https://github.com/hyperledger/fabric-sdk-go">fabric-sdk-go</a>为例搭建一个简单服务端程序。</p>

<p>首先安装fabric开发基础库:</p>

<p>```bash
go get -u github.com/hyperledger/fabric/orderer
go get -u github.com/hyperledger/fabric/peer
go get -u github.com/hyperledger/fabric-sdk-go</p>

<h1 id="optional---populate-vendor-directory-if-needed-by-your-downstream-vendoring-solution">Optional - populate vendor directory (if needed by your downstream vendoring solution)</h1>
<p># cd $GOPATH/src/github.com/hyperledger/fabric-sdk-go/
# make populate
```</p>

<h1 id="section">准备基础配置文件</h1>

<p>首先准备一份客户端连接的配置文件，配置连接orderer、peer节点，证书路径等信息:</p>

<p>```yaml config_e2e.yaml
#
# Schema version of the content. Used by the SDK to apply the corresponding parsing rules.
#
version: 1.0.0</p>

<p>#
# The client section used by GO SDK.
#
client:</p>

<p># Which organization does this application instance belong to? The value must be the name of an org
  # defined under “organizations”
  organization: org1</p>

<p>logging:
    level: info</p>

<p># Root of the MSP directories with keys and certs.
  cryptoconfig:
    path: /home/ubuntu/.local/src/playfabric/first-network/crypto-config</p>

<p># Some SDKs support pluggable KV stores, the properties under “credentialStore”
  # are implementation specific
  credentialStore:
    # [Optional]. Used by user store. Not needed if all credentials are embedded in configuration
    # and enrollments are performed elswhere.
    path: “/tmp/state-store”</p>

<pre><code># [Optional]. Specific to the CryptoSuite implementation used by GO SDK. Software-based implementations
# requiring a key store. PKCS#11 based implementations does not.
cryptoStore:
  # Specific to the underlying KeyValueStore that backs the crypto key store.
  path: /tmp/msp
</code></pre>

<p># BCCSP config for the client. Used by GO SDK.
  BCCSP:
    security:
     enabled: true
     default:
      provider: “SW”
     hashAlgorithm: “SHA2”
     softVerify: true
     level: 256</p>

<p>tlsCerts:
    # [Optional]. Use system certificate pool when connecting to peers, orderers (for negotiating TLS) Default: false
    systemCertPool: false</p>

<p>channels:
  # name of the channel
  mychannel:
    # Required. list of peers from participating orgs
    peers:
      peer0.org1.example.com:
        # [Optional]. will this peer be sent transaction proposals for endorsement? The peer must
        # have the chaincode installed. The app can also use this property to decide which peers
        # to send the chaincode install request. Default: true
        endorsingPeer: true</p>

<pre><code>    # [Optional]. will this peer be sent query proposals? The peer must have the chaincode
    # installed. The app can also use this property to decide which peers to send the
    # chaincode install request. Default: true
    chaincodeQuery: true

    # [Optional]. will this peer be sent query proposals that do not require chaincodes, like
    # queryBlock(), queryTransaction(), etc. Default: true
    ledgerQuery: true

    # [Optional]. will this peer be the target of the SDK's listener registration? All peers can
    # produce events but the app typically only needs to connect to one to listen to events.
    # Default: true
    eventSource: true

# [Optional]. The application can use these options to perform channel operations like retrieving channel
# config etc.
policies:
  #[Optional] options for retrieving channel configuration blocks
  queryChannelConfig:
    #[Optional] min number of success responses (from targets/peers)
    minResponses: 1
    #[Optional] channel config will be retrieved for these number of random targets
    maxTargets: 1
    #[Optional] retry options for query config block
    retryOpts:
      #[Optional] number of retry attempts
      attempts: 5
      #[Optional] the back off interval for the first retry attempt
      initialBackoff: 500ms
      #[Optional] the maximum back off interval for any retry attempt
      maxBackoff: 5s
      #[Optional] he factor by which the initial back off period is exponentially incremented
      backoffFactor: 2.0
</code></pre>

<p>#
# list of participating organizations in this network
#
organizations:
  org1:
    mspid: Org1MSP</p>

<pre><code># This org's MSP store (absolute path or relative to client.cryptoconfig)
cryptoPath:  peerOrganizations/org1.example.com/users/{username}@org1.example.com/msp

peers:
  - peer0.org1.example.com
  - peer1.org1.example.com

# [Optional]. Certificate Authorities issue certificates for identification purposes in a Fabric based
# network. Typically certificates provisioning is done in a separate process outside of the
# runtime network. Fabric-CA is a special certificate authority that provides a REST APIs for
# dynamic certificate management (enroll, revoke, re-enroll). The following section is only for
# Fabric-CA servers.
certificateAuthorities:
  - ca.org1.example.com
</code></pre>

<p># the profile will contain public information about organizations other than the one it belongs to.
  # These are necessary information to make transaction lifecycles work, including MSP IDs and
  # peers with a public URL to send transaction proposals. The file will not contain private
  # information reserved for members of the organization, such as admin key and certificate,
  # fabric-ca registrar enroll ID and secret, etc.
  org2:
    mspid: Org2MSP</p>

<pre><code># This org's MSP store (absolute path or relative to client.cryptoconfig)
cryptoPath:  peerOrganizations/org2.example.com/users/{username}@org2.example.com/msp

peers:
  - peer0.org2.example.com

certificateAuthorities:
  - ca.org2.example.com
</code></pre>

<p># Orderer Org name
  ordererorg:
      # Membership Service Provider ID for this organization
      mspID: OrdererMSP</p>

<pre><code>  # Needed to load users crypto keys and certs for this org (absolute path or relative to global crypto path, DEV mode)
  cryptoPath: ordererOrganizations/example.com/users/{username}@example.com/msp
</code></pre>

<p>#
# List of orderers to send transaction and channel create/update requests to. For the time
# being only one orderer is needed. If more than one is defined, which one get used by the
# SDK is implementation specific. Consult each SDK’s documentation for its handling of orderers.
#
orderers:
  orderer.example.com:
    url: orderer.example.com:7050</p>

<pre><code># these are standard properties defined by the gRPC library
# they will be passed in as-is to gRPC client constructor
grpcOptions:
  ssl-target-name-override: orderer.example.com
  # These parameters should be set in coordination with the keepalive policy on the server,
  # as incompatible settings can result in closing of connection.
  # When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled
  keep-alive-time: 0s
  keep-alive-timeout: 20s
  keep-alive-permit: false
  fail-fast: false
  # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
  allow-insecure: false

tlsCACerts:
  # Certificate location absolute path
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem
</code></pre>

<p>#
# List of peers to send various requests to, including endorsement, query
# and event listener registration.
#
peers:
  peer0.org1.example.com:
    # this URL is used to send endorsement and query requests
    url: peer0.org1.example.com:7051
    # eventUrl is only needed when using eventhub (default is delivery service)
    eventUrl: peer0.org1.example.com:7053</p>

<pre><code>grpcOptions:
  ssl-target-name-override: peer0.org1.example.com
  # These parameters should be set in coordination with the keepalive policy on the server,
  # as incompatible settings can result in closing of connection.
  # When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled
  keep-alive-time: 0s
  keep-alive-timeout: 20s
  keep-alive-permit: false
  fail-fast: false
  # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
  allow-insecure: false

tlsCACerts:
  # Certificate location absolute path
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/peerOrganizations/org1.example.com/tlsca/tlsca.org1.example.com-cert.pem
</code></pre>

<p>peer1.org1.example.com:
    # this URL is used to send endorsement and query requests
    url: peer1.org1.example.com:7151
    # eventUrl is only needed when using eventhub (default is delivery service)
    eventUrl: peer1.org1.example.com:7153</p>

<pre><code>grpcOptions:
  ssl-target-name-override: peer1.org1.example.com
  # These parameters should be set in coordination with the keepalive policy on the server,
  # as incompatible settings can result in closing of connection.
  # When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled
  keep-alive-time: 0s
  keep-alive-timeout: 20s
  keep-alive-permit: false
  fail-fast: false
  # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
  allow-insecure: false

tlsCACerts:
  # Certificate location absolute path
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/peerOrganizations/org1.example.com/tlsca/tlsca.org1.example.com-cert.pem
</code></pre>

<p>peer0.org2.example.com:
    url: peer0.org2.example.com:8051
    # eventUrl is only needed when using eventhub (default is delivery service)
    eventUrl: peer0.org2.example.com:8053
    grpcOptions:
      ssl-target-name-override: peer0.org2.example.com
      # These parameters should be set in coordination with the keepalive policy on the server,
      # as incompatible settings can result in closing of connection.
      # When duration of the ‘keep-alive-time’ is set to 0 or less the keep alive client parameters are disabled
      keep-alive-time: 0s
      keep-alive-timeout: 20s
      keep-alive-permit: false
      fail-fast: false
      # allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs
      allow-insecure: false</p>

<pre><code>tlsCACerts:
  path: /home/ubuntu/repository/golang-repos/src/playfabric/first-network/crypto-config/peerOrganizations/org2.example.com/tlsca/tlsca.org2.example.com-cert.pem ```
</code></pre>

<h1 id="sdk">初始化sdk</h1>

<p>使用<code>github.com/hyperledger/fabric-sdk-go/pkg/core/config</code>包读取并解析配置文件,加载完成后即可初始化sdk</p>

<p><code>go
configPath := os.Getenv("GOPATH") + "/src/playfabric/config_e2e.yaml"
configOpt := config.FromFile(configPath)
sdk, err := fabsdk.New(configOpt)
if err != nil {
	fmt.Println(err)
	os.Exit(1)
}
defer sdk.Close()
</code></p>

<h1 id="section-1">初始化通道</h1>

<p>初始化channelContext及channel,至此初始化工作完成，可以操作chain code或者查询账本。</p>

<p><code>go
//prepare channel client context using client context
clientChannelContext := sdk.ChannelContext("mychannel", fabsdk.WithUser("User1"), fabsdk.WithOrg(orgName))
// Channel client is used to query and execute transactions (Org1 is default org)
client, err := channel.New(clientChannelContext)
if err != nil {
	fmt.Printf("Failed to create new channel client: %s", err)
	os.Exit(1)
}
</code></p>

<h1 id="chaincode">操作ChainCode</h1>

<p>以官方example02的chain code（代币转移合约）为例:</p>

<p><code>go
// a =&gt; b转账2个代币
func executeCC(client *channel.Client) error {
	res, err := client.Execute(channel.Request{ChaincodeID: ccID, Fcn: "invoke", Args: makeArgs("a", "b", "2")},
		channel.WithRetry(retry.DefaultChannelOpts))
	fmt.Println("exe tx:", res.TransactionID)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return err
}
// 查询某个账户代币余额
func queryCC(client *channel.Client, who string) []byte {
	response, err := client.Query(channel.Request{ChaincodeID: ccID, Fcn: "query", Args: makeArgs(who)},
		channel.WithRetry(retry.DefaultChannelOpts),
		channel.WithTargetEndpoints(),
	)
	fmt.Println("query tx:", response.TransactionID)
	if err != nil {
		fmt.Printf("Failed to query funds: %s", err)
		os.Exit(1)
	}
	return response.Payload
}
</code></p>

<h1 id="section-2">完整示例</h1>

<p>完整示例很简单，包含代币转让及查询、底层账本查询（对应fabric1.1，BYFN示例网络）</p>

<p>```go
package main</p>

<p>import (
	“encoding/hex”
	“fmt”
	“github.com/hyperledger/fabric-sdk-go/pkg/client/ledger”
	“github.com/hyperledger/fabric-sdk-go/third_party/github.com/hyperledger/fabric/protos/common”
	“github.com/hyperledger/fabric/common/util”
	“github.com/hyperledger/fabric-sdk-go/pkg/common/errors/retry”
	“github.com/hyperledger/fabric-sdk-go/pkg/client/channel”
	“github.com/hyperledger/fabric-sdk-go/pkg/core/config”
	“github.com/hyperledger/fabric-sdk-go/pkg/fabsdk”
	“os”
)</p>

<p>const (
	channelID      = “mychannel”
	orgName        = “Org1”
	orgAdmin       = “Admin”
	ordererOrgName = “OrdererOrg”
	ccID           = “mycc”
)</p>

<p>func queryLedgerExample() {
	configPath := os.Getenv(“GOPATH”) + “/src/playfabric/config_e2e.yaml”
	configOpt := config.FromFile(configPath)
	sdk, err := fabsdk.New(configOpt)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	defer sdk.Close()
	//prepare channel client context using client context
	clientChannelContext := sdk.ChannelContext(channelID, fabsdk.WithUser(“User1”), fabsdk.WithOrg(orgName))
	// Channel client is used to query and execute transactions (Org1 is default org)
	client, err := ledger.New(clientChannelContext)
	if err != nil {
		fmt.Printf(“Failed to create new channel client: %s”, err)
		os.Exit(1)
	}
	ledgerInfo, err := client.QueryInfo()
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	printBCI(ledgerInfo.BCI)
	block, err := client.QueryBlock(ledgerInfo.BCI.GetHeight() - 1)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	printBlock(block)
	// txid := “63abb9a2ae8e7f3f689498f4ccedef6001ab7902ba9dfe69e2c270a4f7ff1d4d”
	// tx, err := client.QueryTransaction(fab.TransactionID(txid))
	// if err != nil {
	// 	fmt.Println(err)
	// 	os.Exit(1)
	// }
	// fmt.Println(“Tx:”, txid, “payload:”, hex.EncodeToString(tx.GetTransactionEnvelope().GetPayload()))
}</p>

<p>func printBCI(blk *common.BlockchainInfo) {
	fmt.Println(“block height:”, blk.GetHeight())
	fmt.Println(“block hash:”, hex.EncodeToString(blk.GetCurrentBlockHash()))
	fmt.Println(“block prevhash:”, hex.EncodeToString(blk.GetPreviousBlockHash()))
	fmt.Println(“=====================================================”)
}</p>

<p>func printBlock(blk *common.Block) {
	fmt.Printf(“BlockNO:%v\n”, blk.GetHeader().GetNumber())
	fmt.Println(“prevhash:”, hex.EncodeToString(blk.GetHeader().GetPreviousHash()))
	fmt.Println(“hash:”, hex.EncodeToString(util.ComputeSHA256(util.ConcatenateBytes(blk.GetData().GetData()…))))
	fmt.Println(“=====================================================”)
}</p>

<p>func main() {
	configPath := os.Getenv(“GOPATH”) + “/src/playfabric/config_e2e.yaml”
	configOpt := config.FromFile(configPath)
	sdk, err := fabsdk.New(configOpt)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	defer sdk.Close()
	//prepare channel client context using client context
	clientChannelContext := sdk.ChannelContext(channelID, fabsdk.WithUser(“User1”), fabsdk.WithOrg(orgName))
	// Channel client is used to query and execute transactions (Org1 is default org)
	client, err := channel.New(clientChannelContext)
	if err != nil {
		fmt.Printf(“Failed to create new channel client: %s”, err)
		os.Exit(1)
	}
	fmt.Println(“a”, string(queryCC(client, “a”)))
	fmt.Println(“b”, string(queryCC(client, “b”)))</p>

<pre><code>executeCC(client)

fmt.Println("a", string(queryCC(client, "a")))
fmt.Println("b", string(queryCC(client, "b"))) }
</code></pre>

<p>func executeCC(client *channel.Client) error {
	res, err := client.Execute(channel.Request{ChaincodeID: ccID, Fcn: “invoke”, Args: makeArgs(“a”, “b”, “2”)},
		channel.WithRetry(retry.DefaultChannelOpts))
	fmt.Println(“exe tx:”, res.TransactionID)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	return err
}</p>

<p>func queryCC(client *channel.Client, who string) []byte {
	response, err := client.Query(channel.Request{ChaincodeID: ccID, Fcn: “query”, Args: makeArgs(who)},
		channel.WithRetry(retry.DefaultChannelOpts),
		channel.WithTargetEndpoints(),
	)
	fmt.Println(“query tx:”, response.TransactionID)
	if err != nil {
		fmt.Printf(“Failed to query funds: %s”, err)
		os.Exit(1)
	}
	return response.Payload
}</p>

<p>func makeArgs(args …string) [][]byte {
	var ccargs [][]byte
	for _, arg := range args {
		ccargs = append(ccargs, []byte(arg))
	}
	return ccargs
}
```</p>

<h1 id="section-3">其他官方示例</h1>

<ul>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/e2e/end_to_end.go">E2E Test</a>: Basic example that uses SDK to query and execute transaction</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/pkg/client/ledger/ledger_queries_test.go">Ledger Query Test</a>: Basic example that uses SDK to query a channel’s underlying ledger</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/e2e/orgs/multiple_orgs_test.go">Multi Org Test</a>: An example that has multiple organisations involved in transaction</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/pkg/fabsdk/provider/sdk_provider_test.go">Dynamic Endorser Selection</a>: An example that uses dynamic endorser selection (based on chaincode policy)</li>
  <li><a href="https://github.com/hyperledger/fabric-sdk-go/tree/master/test/integration/e2e/pkcs11/e2e_test.go">E2E PKCS11 Test</a>: E2E Test using a PKCS11 crypto suite and configuration</li>
  <li><a href="https://github.com/securekey/fabric-examples/tree/master/fabric-cli/">CLI</a>: An example CLI for Fabric built with the Go SDK.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hyperledger-fabric分布式部署]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/07/23/hyperledger-fabricfen-bu-shi-bu-shu/"/>
    <updated>2018-07-23T10:48:30+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/07/23/hyperledger-fabricfen-bu-shi-bu-shu</id>
    <content type="html"><![CDATA[<p>fabric官方文档给出了怎样搭建第一个联盟网络(<a href="https://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">Build your first network</a>),然而这个文档实际只给出了单机部署多个docker实例的例子,如果要在真实分布式环境部署，还是得费不少力气.</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">基本思路</a></li>
  <li><a href="#section-1">搭建流程</a>    <ul>
      <li><a href="#section-2">创建必要配置文件</a></li>
      <li><a href="#swarm">创建swarm集群</a></li>
      <li><a href="#section-3">创建集群网络</a></li>
      <li><a href="#fabric">创建fabric控制脚本</a></li>
    </ul>
  </li>
  <li><a href="#startpeer-0-1-means-start-peer-0-of-org-1">startPeer 0 1 means start peer 0 of org 1</a></li>
  <li><a href="#scriptsscriptsh-channelname-clidelay-language-clitimeout">scripts/script.sh $CHANNEL_NAME $CLI_DELAY $LANGUAGE $CLI_TIMEOUT</a>    <ul>
      <li><a href="#section-4">启动网络</a>        <ul>
          <li><a href="#orderer">启动orderer</a></li>
          <li><a href="#peer">启动peer</a></li>
          <li><a href="#fabric-1">配置fabric网络</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-5">后记</a></li>
</ul>

<h1 id="section">基本思路</h1>

<blockquote>
  <p>题外话:老实说，fabric这个部署文档写得并不漂亮。因为他引入了过多的先决知识，譬如docker,docker-compose等多个docker组件，虽然使用docker大大提高了部署成功率，然而这样做对于fabric入门来说却走偏了，容易让初学者产生一种疑惑: 好似很容易就”得到”了一个完整的fabric网络，然而实际上，好像对于fabric是怎么运行起来的仍然一无所知。如果想要了解怎么样一步步将fabric搭建起来的话，可以仔细看看<code>fabric-samples/first-network</code>文件夹的脚本及compose配置文件，或者参考<code>[区块链原理、设计、与应用] 作者:杨保华,陈昌</code>这本书第9章,相信这样的搭建教程才能让人有直观的了解。所以，本文也不必一步步拆分搭建步骤，本文的目的是为了想读者展示如果利用现有的BYFN文档及脚本搭建真正分布式网络。</p>
</blockquote>

<p>所有的宿主机环境以及fabric二进制程序的安装还是按照Build Your First Network文档所说进行，在完成后，用docker swarm将各个宿主机上的docker实例连接起来。</p>

<h1 id="section-1">搭建流程</h1>

<p>假设我们有5台宿主机</p>

<ul>
  <li>orderer(cli) 我们将在orderer宿主机上启动客户端cli配置网络，实际上这个cli可以在任意机器上启动</li>
  <li>peer0.org1</li>
  <li>peer1.org1</li>
  <li>peer0.org2</li>
  <li>peer1.org2</li>
</ul>

<p>在5台宿主机上同构部署fabric环境，具体操作参考<a href="https://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">Build your first network</a></p>

<h2 id="section-2">创建必要配置文件</h2>

<p>在任意一台机器上生成配置文件:</p>

<p><code>
cd ./fabric-samples/first-network
./byfn.sh generate
</code></p>

<p>然后将生成的配置同步到所有其他几台宿主机的相同目录,同步的文件包含</p>

<ul>
  <li>channel-artifacts</li>
  <li>crypto-config</li>
</ul>

<h2 id="swarm">创建swarm集群</h2>

<p>假设我们将cli作为集群manager，则在cli上创建swarm集群:</p>

<p><code>
docker swarm init
</code></p>

<p>查看集群join token:</p>

<p><code>
docker swarm join-token manager
</code></p>

<p>输出可能类似这样:</p>

<p><code>
docker swarm join — token SWMTKN-1–3as8cvf3yxk8e7zj98954jhjza3w75mngmxh543llgpo0c8k7z-61zyibtaqjjimkqj8p6t9lwgu 172.16.0.153:2377
</code></p>

<p>在其他所有机器上执行这条输出的命令，完成后说明所以机器处于同一集群.</p>

<h2 id="section-3">创建集群网络</h2>

<p>在cli宿主机执行</p>

<p><code>
docker network create --attachable --driver overlay byfn
</code></p>

<h2 id="fabric">创建fabric控制脚本</h2>

<p>现在，所有宿主均处于swarm集群，然而docker-compose并不直接使用swarm,所以我这里不再使用docker-compose，原因有两个: 1.docker-compose主要用于多个服务打包部署，然而我们在每个宿主机仅部署单个docker，不必非要使用compose 2.docker-compose还需要单独配置才能运行在swarm模式下。 所以，我将docker启动命令独立出来，写入一个shell脚本，将这个shell脚本放入所有宿主机<code>./fabric-samples/first-network/</code>下命令为<code>control</code>文件.</p>

<p>```bash
#!/bin/bash
NETWORK=byfn    # 网络名称必须和创建的集群网络名称一致
IMAGETAG=latest</p>

<p>function startOrderer()
{
    docker run –rm -d –network=${NETWORK} –name orderer.example.com -p 7050:7050 \
    -e ORDERER_GENERAL_LOGLEVEL=INFO \
    -e ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 \
    -e ORDERER_GENERAL_GENESISMETHOD=file \
    -e ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block \
    -e ORDERER_GENERAL_LOCALMSPID=OrdererMSP \
    -e ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp \
    -e ORDERER_GENERAL_TLS_ENABLED=true \
    -e ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key \
    -e ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt \
    -e ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/channel-artifacts/genesis.block,target=/var/hyperledger/orderer/orderer.genesis.block    \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp,target=/var/hyperledger/orderer/msp    \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/,target=/var/hyperledger/orderer/tls    \
    hyperledger/fabric-orderer:${IMAGETAG} orderer
}</p>

<h1 id="startpeer-0-1-means-start-peer-0-of-org-1">startPeer 0 1 means start peer 0 of org 1</h1>
<p>function startPeer()
{
	PEER=$1
	ORG=$2
	PEER2=1
	[ $PEER -eq 1 ] &amp;&amp; PEER2=0
	BOOT=peer${PEER2}.org${ORG}.example.com:7051
    docker run –rm -d  –network=${NETWORK} –name peer${PEER}.org${ORG}.example.com -p 7051:7051 -p 7053:7053 \
    -e CORE_PEER_ID=peer${PEER}.org${ORG}.example.com \
    -e CORE_PEER_ADDRESS=peer${PEER}.org${ORG}.example.com:7051 \
    -e CORE_PEER_GOSSIP_BOOTSTRAP=${BOOT} \
    -e CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer${PEER}.org${ORG}.example.com:7051 \
    -e CORE_PEER_LOCALMSPID=Org${ORG}MSP \
    -e CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock \
    -e CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${NETWORK} \
    -e CORE_LOGGING_LEVEL=INFO \
    -e CORE_PEER_TLS_ENABLED=true \
    -e CORE_PEER_GOSSIP_USELEADERELECTION=true \
    -e CORE_PEER_GOSSIP_ORGLEADER=false \
    -e CORE_PEER_PROFILE_ENABLED=true \
    -e CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt \
    -e CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key \
    -e CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt \
    –mount type=bind,source=/var/run/,target=/host/var/run/ \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/crypto-config/peerOrganizations/org${ORG}.example.com/peers/peer${PEER}.org${ORG}.example.com/msp,target=/etc/hyperledger/fabric/msp \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/crypto-config/peerOrganizations/org${ORG}.example.com/peers/peer${PEER}.org${ORG}.example.com/tls,target=/etc/hyperledger/fabric/tls \
    hyperledger/fabric-peer:${IMAGETAG}  peer node start
}</p>

<h1 id="scriptsscriptsh-channelname-clidelay-language-clitimeout">scripts/script.sh $CHANNEL_NAME $CLI_DELAY $LANGUAGE $CLI_TIMEOUT</h1>
<p>function startCli()
{
    docker run –rm -it –network=${NETWORK} –name cli \
    -e  CHANNEL_NAME=”mychannel” \
    -e  CLI_DELAY=3 \
    -e  LANGUAGE=golang \
    -e  CLI_TIMEOUT=10 \
    -e  GOPATH=/opt/gopath \
    -e  CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock \
    -e  CORE_LOGGING_LEVEL=INFO \
    -e  CORE_PEER_ID=cli \
    -e  CORE_PEER_ADDRESS=peer0.org1.example.com:7051 \
    -e  CORE_PEER_LOCALMSPID=Org1MSP \
    -e  CORE_PEER_TLS_ENABLED=true \
    -e  CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt \
    -e  CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key \
    -e  CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt \
    -e  CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp \
    –mount type=bind,source=/var/run/,target=/host/var/run/ \
    –mount type=bind,source=/root/fabric/fabric-samples/chaincode/,target=/opt/gopath/src/github.com/chaincode \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/crypto-config,target=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/scripts,target=/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ \
    –mount type=bind,source=/root/fabric/fabric-samples/first-network/channel-artifacts,target=/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts \
    –workdir /opt/gopath/src/github.com/hyperledger/fabric/peer \
    hyperledger/fabric-tools:${IMAGETAG} /bin/bash
}</p>

<p>case X$1 in
    Xorderer)
        startOrderer
        ;;
    Xpeer)
        startPeer $2 $3
        ;;
    Xcli)
        startCli
        ;;      <br />
    X*)
        echo “Usage: $0 orderer|peer|cli”
        exit -1
        ;;
esac
```</p>

<h2 id="section-4">启动网络</h2>

<h3 id="orderer">启动orderer</h3>

<p>在orderer宿主机执行</p>

<p><code>
cd ./fabric-samples/first-network
./contrl orderer
</code></p>

<h3 id="peer">启动peer</h3>

<p>在peer0.org1宿主机执行</p>

<p><code>
cd ./fabric-samples/first-network
./contrl peer 0 1
</code></p>

<p>在peer1.org1宿主机执行</p>

<p><code>
cd ./fabric-samples/first-network
./contrl peer 1 1
</code></p>

<p>同理启动org2的peer</p>

<h3 id="fabric-1">配置fabric网络</h3>

<p>在任意宿主机,这里我们就用orderer宿主机:</p>

<p><code>
cd ./fabric-samples/first-network
./control cli
</code></p>

<p>执行这个命令后进入客户端配置实例,直接运行配置脚本即可:</p>

<p><code>
scripts/script.sh $CHANNEL_NAME $CLI_DELAY $LANGUAGE $CLI_TIMEOUT
</code></p>

<p>出现的配置及测试输出应该和单机部署一样,至此部署完成。</p>

<h1 id="section-5">后记</h1>

<p>按这个步骤，应该是可以将这个分布式fabric搭建起来的，但是其他优化还需要自行完成，比如为了测试方便，我并没有将区块链数据挂载出来，所以docker重启后区块数据就没有了，生产环境得自己将数据卷挂载上去；还有，为了权限隔离，一般也不会将整个crypto-config文件夹分发给各个联盟节点，而是需要什么给什么，保持目录结构一致即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用call实现合约任意调用]]></title>
    <link href="http://qjpcpu.github.io/blog/2018/07/02/li-yong-callshi-xian-he-yue-ren-yi-diao-yong/"/>
    <updated>2018-07-02T13:50:25+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2018/07/02/li-yong-callshi-xian-he-yue-ren-yi-diao-yong</id>
    <content type="html"><![CDATA[<p>call()是一个底层的接口，用来向一个合约发送消息，也就是说如果你想实现自己的消息传递，可以使用这个函数。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">需求场景</a>    <ul>
      <li><a href="#section-1">业务需求</a></li>
      <li><a href="#section-2">明确需求</a></li>
    </ul>
  </li>
  <li><a href="#section-3">实现关键点</a>    <ul>
      <li><a href="#section-4">调用任意合约</a></li>
      <li><a href="#section-5">权限控制</a></li>
    </ul>
  </li>
  <li><a href="#section-6">实现参考</a>    <ul>
      <li><a href="#section-7">热钱包工厂</a></li>
      <li><a href="#section-8">热钱包合约</a></li>
    </ul>
  </li>
  <li><a href="#section-9">后记</a></li>
</ul>

<h1 id="section">需求场景</h1>

<p>“合约动态调用”的需求场景是什么呢,答案是”热钱包”。为什么是热钱包呢,我们可以从最终需求出发一步步来推导:</p>

<h2 id="section-1">业务需求</h2>

<p>首先,假设一个业务需求，我们现在要做一个ERC721的热钱包，用户可以托管他全部的数字资产给项目方，项目方代表用户对其资产进行任意操作，这样我们可以向用户屏蔽以太坊的细节，大大提升用户体验，只有当用户想要提现资产的时候，才把资产归还到用户的冷钱包地址中去。</p>

<h2 id="section-2">明确需求</h2>

<p>初看这个需求很简单，我们可以为每个用户生成一个私钥从而建立对应地址。每次需要对资产进行操作的时候，读取这个私钥进行链上交互就行了。</p>

<p>好像很完美，但细想下来，在真正生产环境中实践却会有诸多问题: 首先带来的就是管理问题，众多的私钥不容许有一丝数据的丢失损坏，否则就需要承担用户资产的遗失风险; 其次是泄露的风险，私钥的众多更加大了泄露的风险系数，一旦有任何一个私钥泄露，项目方基本上是属于束手无策的，以太坊上可没有账户封禁这一说。</p>

<p>那么，怎么解决这个问题呢？我这里提供的一个解决方案就是利用合约。</p>

<p>我们为每个用户创建的热钱包并不是一个普通钱包地址，而是一个合约。所有的用户的热钱包都统一受控于项目方的管理账户地址,只有管理账户有权操作合约，如果有任何问题，我们只需要使用管理账户进行维护操作就行，不需要更改其他东西。 但利用合约来做热钱包又带来另一个问题，合约能调用的方法在上链之后就无法更改了或新增了，如果我们要对接的某个721藏品后续支持了某个新方法，那么我们的热钱包岂不是不能完成这个调用了？所以，如果使用合约做热钱包，还必须能够实现这个钱包合约能够动态调用其他合约。</p>

<p>归纳一下，这个721热钱包细化下来的技术需求有这样几点需要满足:</p>

<ol>
  <li>管理收敛，所有热钱包管理最好收敛到一个管理账户下</li>
  <li>管理账户能更改</li>
  <li>如果是合约热钱包,这个钱包必须能适配各类标准非标准藏品合约的调用</li>
</ol>

<p>这里对第3点补充说明一下，可能有的读者会疑惑，既然erc721都是标准化的协议，为什么还需要适配各种非标接口呢？原因之一是我们业务需求里已经说了，要能对用户资产进行任意操作，不仅仅限制于基本721的几个API。此外，ERC721的藏品通常都不会只包含721协议里几个基础接口，各个项目方会根据自己的业务研发出诸如繁殖、战斗等等资产操作，一个好的721钱包最好是能适配这些功能。还有，即便是ERC721协议本身，也可能出现变动，比如日前刚确认的721协议的最终版和以CryptoKitty所代表的beta版，协议本身就差别不小。</p>

<h1 id="section-3">实现关键点</h1>

<h2 id="section-4">调用任意合约</h2>

<p>这是本文要讲述的关键点。</p>

<p>其实要实现这个功能,使用<code>call</code>方法就可以了。call调用失败会返回一个调用成功与否的布尔值，需要检查一下</p>

<p><code>javascript
contract DynamicCaller{
    function dyn_call(address _constract, bytes _data) public payable{
        if (!_constract.call.value(msg.value)(_data)){
            revert();
        }
    }
}
</code></p>

<p>如果<code>DynamicCaller</code>就是我们的热钱包合约，那么这个<code>dyn_call</code>方法就可以实现任意调用，注意这个动态方法最终调用的合约和对应方法都是由参数传递进来；</p>

<p>在ropsten部署这个合约,合约地址是<code>0x5ec567cf2137da526945f4820d0c0621ddcd02ce</code>。现在我们有一份任意合约<code>AnyContract</code>(这里先不以ERC721合约举例，为了阐明任意调用这个点，使用了一个简单合约示例)</p>

<p>```javascript
contract AnyContract{
    mapping(address =&gt; uint256) public numbers;
    mapping(address =&gt; string) public texts;</p>

<pre><code>function add(uint256 _a,uint256 _b) public{
    numbers[msg.sender] =_a+_b;
}

function write(string _text) public{
    texts[msg.sender] = _text;
}

function batchWrite(uint256 _a,uint256 _b,string _text) public payable{
    numbers[msg.sender] =_a+_b;
    texts[msg.sender] = _text;
}
function getBalance() public view returns(uint256){
    return address(this).balance;
} } ```
</code></pre>

<p>现在我们怎么进行调用呢？我们可以使用<code>github.com/qjpcpu/ethereum/contracts</code>提供的参数打包方法<code>PackArguments</code>生成<code>dyn_call</code>要的数据，比如我们要从<code>DynamicCaller</code>调用<code>AnyContract</code>的add方法:</p>

<p><code>go
anyABI, _ = contracts.ParseABI("[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"texts\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"uint256\"},{\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"uint256\"},{\"name\":\"_b\",\"type\":\"uint256\"},{\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"batchWrite\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numbers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"write\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]")
data, err := contracts.PackArguments(anyABI, "add", big.NewInt(1), big.NewInt(2))
if err != nil {
	return err
}
builder := contracts.NewTxOptsBuilderFromPK(pk)
dc, _ := NewDynamicCaller(common.HexToAddress(DynamicCallerAddres), conn)
tx, err := dc.DynCall(builder.Get(), common.HexToAddress("0x2f44fc640F9708FD969620466F9eddD21859e8E9"), data)
</code></p>

<p>完整代码示例参考<a href="https://github.com/qjpcpu/dynamic-caller">dynamic-caller</a></p>

<h2 id="section-5">权限控制</h2>

<p>对于热钱包创建合约,需要能更改管理账户,并且<code>dyn_call</code>这个函数只有管理账户能够调用,这个继承<code>Ownable</code>合约就可能办到了。</p>

<p>对于热钱包合约本身,除了提现操作，所有方法调用必须来自管理合约的管理员。</p>

<h1 id="section-6">实现参考</h1>

<h2 id="section-7">热钱包工厂</h2>

<p>热钱包工厂唯一作用就是创建热并记录用户的热钱包，唯一需要注意的就是控制权的管理</p>

<p>```javascript
contract Ownable {
    address public owner;</p>

<pre><code>constructor() public {
    owner = msg.sender;
}

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
        owner = newOwner;
    }
}

function getOwner() public view returns(address) {
    return owner;
}
</code></pre>

<p>}</p>

<p>contract WalletFactory is Ownable {
    // 记录用户热钱包地址
    mapping(address =&gt; address) public hotwallets;</p>

<pre><code>// 仅管理员owner可以创建热钱包
function createWallet(address _owner) public onlyOwner {
    // 每个用户仅有一个热钱包
    require(hotwallets[_owner] == address(0));
    HotWallet w = new HotWallet(address(this), _owner);
    hotwallets[_owner] = address(w);
}

function isWalletFactory() external pure returns(bool){
    return true;
} } ```
</code></pre>

<p>其实，在实际应用中,这里还潜藏了一个问题: 比如通常的产品逻辑会在用户注册完成时就生成热钱包备用,但这个以太坊交易被打包最快可能也要15秒左右，如果我们要在用户注册完成就显示用户热钱包地址好像是不可能的。实际上呢？交易打包确认确实要很长时间,但是我们却可以提前获知热钱包的地址:</p>

<p>以太坊中合约地址的生成规则是这样的:根据<code>(msg.sender + nonce)</code>二元组的hash来生成合约地址的,这个生成算法很简单,有兴趣可以查阅源码<code>crypto</code>包。</p>

<p>举个例子,加入<code>WalletFactory</code>这个合约地址是<code>0x5ec567cf2137da526945f4820d0c0621ddcd02ce</code>,那么第一次调用<code>createWallet</code>时nonce肯定是1，则对应生成的<code>HotWallet</code>地址可以这样算出: <code>addr := crypto.CreateAddress(common.HexToAddress("0x5ec567cf2137da526945f4820d0c0621ddcd02ce"), 1) // 热钱包地址是:0xE139cd3E5FcC127A54B0fF8687c703265E282842</code></p>

<h2 id="section-8">热钱包合约</h2>

<p>```javascript
contract HotWallet {
    address public owner;
    WalletFactory public factory;
    // 这里的owner是热钱包所属用户
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    // 保证动态方法的调用者一定是管理员
    modifier onlyAdmin() {
        require(msg.sender == factory.getOwner());
        _;
    }</p>

<pre><code>constructor(address _admin, address _owner) public {
    require(_admin != address(0) &amp;&amp; _owner != address(0));
    factory = WalletFactory(_admin);
    require(factory.isWalletFactory());
    owner = _owner;
}

function isHotWallet() external pure returns(bool){
    return true;
}

// the msg.sender must be factory.owner
function dyn_call(address _constract, bytes _data) public payable onlyAdmin {
    if (!_constract.call.value(msg.value)(_data)){
        revert();
    }
}

// 能提现eth
function withdraw() external onlyOwner{
    require(owner != address(0));
    owner.transfer(address(this).balance);
}

// 很多场景下都需要能接受eth转账
function() public payable{}

// other functions } ```
</code></pre>

<p><a href="https://github.com/qjpcpu/dynamic-caller/blob/master/wallets.sol">完整合约代码</a></p>

<h1 id="section-9">后记</h1>

<p>要完成个业务特定热钱包,可以在这个基础上修改HotWallet代码即可,比如数字资产的提现等等,但要特别注意: <code>call</code>方法是一个非常底层方法，为了合约安全，该方法不应该接受直接来自用户的数据。</p>

<p>此外,我观察到一些交易所给用户分配的以太热钱包地址也是一份用户独立的合约而不是普通地址,所以我猜想他们可能也是为了业务灵活性和管理性才这样做的，不过是不是使用call来实现，就不得而知了。</p>
]]></content>
  </entry>
  
</feed>
