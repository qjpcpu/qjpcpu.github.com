<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Jason's space]]></title>
  <link href="http://qjpcpu.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://qjpcpu.github.io/"/>
  <updated>2016-02-18T17:16:56+08:00</updated>
  <id>http://qjpcpu.github.io/</id>
  <author>
    <name><![CDATA[Jason]]></name>
    <email><![CDATA[qjpcpu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于后台任务]]></title>
    <link href="http://qjpcpu.github.io/blog/2015/05/27/guan-yu-hou-tai-ren-wu/"/>
    <updated>2015-05-27T17:16:34+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2015/05/27/guan-yu-hou-tai-ren-wu</id>
    <content type="html"><![CDATA[<h3>关于sidekiq</h3>

<p>在做ruby开发时，通常会遇到耗时操作的处理，sidekiq由于其使用简单，性能强劲，所以常被用来作为Ruby应用的后台任务的执行引擎。不过sidekiq有个令人头疼的问题，就是任务提交到后台异步执行后，对于其状态的监测和管理就成为很大的问题。</p>

<!--more-->


<p>sidekiq的wiki上也贴出了很多相关执行管理工具，sidekiq-promise是个人最喜欢的一个，其异步回调的风格和js的风格非常像，使用起来非常友好。</p>

<h3>sidekiq-promise</h3>

<p>这里的例子直接来源于其github的readme:</p>

<p>```ruby demo.rb
class ProcessWorker
  include Sidekiq::Promise</p>

<p>  def perform file_to_process</p>

<pre><code>UnzipWorker.as_promise(file_to_process).then do |dir|
  MrDarcy.all_promises do
    dir.entries.map do |file|
      ImageThumbnailWorker.as_promise(file)
    end
  end
end.then do
  UserNotificationMailer.all_images_processed
end
</code></pre>

<p>  end
end
```</p>

<p>简述: UnzipWorker会解压文件，然后将解压得到的每个文件分发给ImageThumbnailWorker去创建压缩图，等待所有压缩完成后再发送通知邮件，非常简洁漂亮。</p>

<ul>
<li>将worker里的<code>include Sidekiq::Worker</code>替换成<code>include Sidekiq::Promise</code>即可。</li>
<li><p>如果要获取worker的输出，则调用<code>ProcessWorker.as_promise(arguments)</code>即可，在then block中获取执行结果，这个结果即<code>perform</code>方法的返回值。</p></li>
<li><p><code>sidekiq-promise</code>使用了<code>MrDarcy</code>，所以提供了一个很有意思的方法</p></li>
</ul>


<p><code>ruby
MrDarcy.all_promises do
  [promise1,promise2]
end
</code></p>

<p><code>MrDarcy.all_promises</code>的块会等待其中列表的每一个promise完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效读取excel]]></title>
    <link href="http://qjpcpu.github.io/blog/2015/05/25/gao-xiao-du-qu-excel/"/>
    <updated>2015-05-25T11:11:02+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2015/05/25/gao-xiao-du-qu-excel</id>
    <content type="html"><![CDATA[<p>前面介绍ruby写excel文件的一个很cool的gem包<code>axlsx</code>,这里介绍另一个高效读取excel的包<code>creek</code>。</p>

<p>一个读一个写，ruby轻松搞定execel处理。</p>

<!-- more -->


<h4>安装</h4>

<p><code>bash
gem install creek
</code></p>

<h4>使用</h4>

<p><code>creek</code>本身的使用非常简单:</p>

<p>```ruby creek_demo.rb
require &lsquo;creek&rsquo;
creek = Creek::Book.new &ldquo;specs/fixtures/sample.xlsx&rdquo;
sheet= creek.sheets[0]</p>

<h1>注:获取行数不能用size方法</h1>

<p>puts sheet.rows.count # => 100</p>

<p>sheet.rows.each do |row|
  puts row # => {&ldquo;A1&rdquo;=>&ldquo;Content 1&rdquo;, &ldquo;B1&rdquo;=>nil, C1"=>nil, &ldquo;D1&rdquo;=>&ldquo;Content 3&rdquo;}
end</p>

<p>sheet.rows_with_meta_data.each do |row|
  puts row # => {&ldquo;collapsed&rdquo;=>&ldquo;false&rdquo;, &ldquo;customFormat&rdquo;=>&ldquo;false&rdquo;, &ldquo;customHeight&rdquo;=>&ldquo;true&rdquo;, &ldquo;hidden&rdquo;=>&ldquo;false&rdquo;, &ldquo;ht&rdquo;=>&ldquo;12.1&rdquo;, &ldquo;outlineLevel&rdquo;=>&ldquo;0&rdquo;, &ldquo;r&rdquo;=>&ldquo;1&rdquo;, &ldquo;cells&rdquo;=>{&ldquo;A1&rdquo;=>&ldquo;Content 1&rdquo;, &ldquo;B1&rdquo;=>nil, C1"=>nil, &ldquo;D1&rdquo;=>&ldquo;Content 3&rdquo;}}
end</p>

<p>sheet.state   # => &lsquo;visible&rsquo;
sheet.name    # => &lsquo;Sheet1&rsquo;
sheet.rid     # => &lsquo;rId2&rsquo;
```</p>

<h4>性能</h4>

<p>读取并遍历一个16M左右17608行的xlsx文件，benchmark:</p>

<p><code>bash
--------------- total: 84.040000sec   ----------------
  user     system      total        real
 84.920000   0.680000  85.600000 ( 86.084133)
</code></p>

<p>P.S. 无法和其他读取excel的gem做对比，因为试着做对比测试时发现其他gem根本卡在读取操作那不动了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rvm和rbenv环境变量冲突导致无法安装gem包]]></title>
    <link href="http://qjpcpu.github.io/blog/2015/01/05/rvmhe-rbenvhuan-jing-bian-liang-chong-tu-dao-zhi-wu-fa-an-zhuang-gembao/"/>
    <updated>2015-01-05T18:11:47+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2015/01/05/rvmhe-rbenvhuan-jing-bian-liang-chong-tu-dao-zhi-wu-fa-an-zhuang-gembao</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>root环境用rvm安装了ruby，但我需要在用户环境重装ruby，而且个人喜欢用rbenv，这就导致了我安装了rbenv的gem后，没有权限安装gem包。</p>

<!-- more -->


<h2>resolve</h2>

<p>这种情况是rvm强制设置了<code>GEM_HOME</code>导致的，可以<code>gem env</code>查看：</p>

<pre><code>jason@mac:~$ gem env
RubyGems Environment:
  - RUBYGEMS VERSION: 2.0.14
  - RUBY VERSION: 2.0.0 (2014-11-13 patchlevel 598) [x86_64-linux]
  - INSTALLATION DIRECTORY: /usr/local/rvm/gems/ruby-2.0.0-p353
  - RUBY EXECUTABLE: /home/jason/.rbenv/versions/2.0.0-p598/bin/ruby
  - EXECUTABLE DIRECTORY: /usr/local/rvm/gems/ruby-2.0.0-p353/bin
  - RUBYGEMS PLATFORMS:
    - ruby
    - x86_64-linux
  - GEM PATHS:
     - /usr/local/rvm/gems/ruby-2.0.0-p353
     - /home/jason/.rbenv/versions/2.0.0-p598/lib/ruby/gems/2.0.0/
  - GEM CONFIGURATION:
     - :update_sources =&gt; true
     - :verbose =&gt; true
     - :backtrace =&gt; false
     - :bulk_threshold =&gt; 1000
  - REMOTE SOURCES:
     - https://rubygems.org/
</code></pre>

<p>可见GEM PATHS里优先选择了rvm的gem路径，所以需要重设GEM_HOME</p>

<pre><code>export GEM_HOME=$HOME/.rbenv/versions/2.0.0-p598/lib/ruby/gems/2.0.0/
</code></pre>

<p>但是，最好的办法是在~/.bash_profile(centos,ubuntu中是.bashrc)中<code>eval "$(rbenv init -)"</code>前加上：</p>

<pre><code>unset GEM_PATH
unset GEM_HOME
</code></pre>

<p>这样也可以清除rvm的设置，使rbenv的变量被正确设置.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[compile ruby from source]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/03/07/compile-ruby-from-source/"/>
    <updated>2014-03-07T15:35:02+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/03/07/compile-ruby-from-source</id>
    <content type="html"><![CDATA[<h3>下载需要的软件包</h3>

<ul>
<li><a href="http://www.openssl.org/source/">openssl</a></li>
<li><a href="http://pyyaml.org/wiki/PyYAML">yaml</a></li>
<li><a href="https://www.ruby-lang.org">ruby</a></li>
<li><a href="http://sqlite.org/2014/sqlite-autoconf-3080301.tar.gz">sqlite3</a>(可选)</li>
<li><a href="http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz">pkg-config</a>(可选)</li>
</ul>


<!--more-->


<p>假设需要安装的ruby目录为<code>/path/to/ruby_dir</code></p>

<pre><code>export RUBY_DEST=/path/to/ruby_dir
</code></pre>

<h3>编译openssl</h3>

<pre><code>./config --prefix=$RUBY_DEST  shared
make 
make install
</code></pre>

<h3>编译libyaml</h3>

<pre><code>./configure --prefix=$RUBY_DEST
make
make install
</code></pre>

<h3>编译pkg-config(如果版本过低需要安装，否则编译ruby会报错<code>Unknown keyword 'URL' in '.$RUBY_DEST.tmp.pc'</code>)</h3>

<pre><code>./configure --prefix=$RUBY_DEST         \
            --with-internal-glib  \
            --disable-host-tool
</code></pre>

<p>如果报错：</p>

<pre><code>gthread-posix.c: In function `g_system_thread_set_name':
gthread-posix.c:1175: error: `PR_SET_NAME' undeclared (first use in this function)
gthread-posix.c:1175: error: (Each undeclared identifier is reported only once
gthread-posix.c:1175: error: for each function it appears in.)
</code></pre>

<p>就需要在pkg源码目录下glib/glib/gthread.c添加：</p>

<pre><code>#define PR_SET_NAME    15               /* Set process name */
#define PR_GET_NAME    16               /* Get process name */
</code></pre>

<p>然后再继续编译</p>

<pre><code>make &amp;&amp; make install
</code></pre>

<h3>编译ruby</h3>

<p>先导入环境变量,否则ruby找不到ssl的链接目录</p>

<pre><code>export LD_LIBRARY_PATH=$RUBY_DEST/lib
export C_INCLUDE_PATH=$RUBY_DEST/include
</code></pre>

<p>开始编译ruby</p>

<pre><code>./configure --prefix=$RUBY_DEST --with-opt-dir=$RUBY_DEST
make
make install
</code></pre>

<h3>编译sqlite3(可选)</h3>

<h3>测试</h3>

<pre><code>$RUBY_DEST/bin/ruby -v #打印版本号，说明安装成功
export PATH=$PATH:$RUBY_DEST/bin
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[axlsx报表工具(四)——条件格式化]]></title>
    <link href="http://qjpcpu.github.io/blog/2014/02/15/axlsxbao-biao-gong-ju-si-tiao-jian-ge-shi-hua/"/>
    <updated>2014-02-15T00:47:04+08:00</updated>
    <id>http://qjpcpu.github.io/blog/2014/02/15/axlsxbao-biao-gong-ju-si-tiao-jian-ge-shi-hua</id>
    <content type="html"><![CDATA[<h3>定义格式化操作</h3>

<p>条件格式化风格定义也是使用格式化定义语句add_style，不同的是必须将type指定为:dxf。</p>

<p>``` ruby</p>

<h1>define the style for conditional formatting</h1>

<p>profitable = book.styles.add_style( :fg_color => &ldquo;FF428751&rdquo;, :type => :dxf )
unprofitable = book.styles.add_style( :fg_color => &ldquo;FF0000&rdquo;, :type => :dxf )
```</p>

<p>条件格式化有四种类型cellIs，colorScale，dataBar，iconSet。</p>

<!-- more -->


<h3>cellIs</h3>

<p>cellIs条件格式化使用得较为普遍，即对满足条件的单元格更改字体颜色，字体大小，背景色等等。</p>

<p><img src="http://e.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=0cc20173b8a1cd1101b672258929b9c1/d000baa1cd11728bb30e6961cafcc3cec3fd2c56.jpg?referer=3c8b0130af4bd1135dda82028c4c&amp;x=.jpg" alt="image" /></p>

<p>对于B列，如果数值大于100000表示盈利，则更改字体颜色；对于亏损的，则在C列中将百分比小于100%的赤字显示。</p>

<p>``` ruby
book.add_worksheet(:name => &ldquo;Cell Is&rdquo;) do |ws|</p>

<h1>产生20行数据</h1>

<p>ws.add_row [&ldquo;Previous Year Quarterly Profits (JPY)&rdquo;]
ws.add_row [&ldquo;Quarter&rdquo;, &ldquo;Profit&rdquo;, &ldquo;% of Total&rdquo;]
offset = 3
rows = 20
offset.upto(rows + offset) do |i|
 ws.add_row [&ldquo;Q#{i}&rdquo;, 10000<em>((rows/2-i) * (rows/2-i)), &ldquo;=100</em>B#{i}/SUM(B3:B#{rows+offset})&rdquo;], :style=>[nil, money, percent]
end</p>

<h1>格式化条件>100000</h1>

<p>ws.add_conditional_formatting(&ldquo;B3:B100&rdquo;, { :type => :cellIs, :operator => :greaterThan, :formula => &ldquo;100000&rdquo;, :dxfId => profitable, :priority => 1 })</p>

<h1>格式化条件0.00%&lt;x&lt;100%</h1>

<p>ws.add_conditional_formatting(&ldquo;C3:C100&rdquo;, { :type => :cellIs, :operator => :between, :formula => [&ldquo;0.00%&rdquo;,&ldquo;100.00%&rdquo;], :dxfId => unprofitable, :priority => 1 })
end
```</p>

<p>add_conditional_formatting方法指定条件格式化，类型type是cellIs，条件由operator和formula共同指定，dxfId就是我们上面定义的格式化操作，priority优先级数值越小，优先级越高。</p>

<h3>colorScale</h3>

<p><img src="http://h.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=3d1d3870938fa0ec7bc7640816ac28d3/f603918fa0ec08fa0ef0e9e45bee3d6d54fbda85.jpg?referer=6b56cc4859b5c9ea3be437d3269b&amp;x=.jpg" alt="image" /></p>

<p>colorScale是以颜色渐变的方式来格式化表格。</p>

<p>```ruby
book.add_worksheet(:name => &ldquo;Color Scale&rdquo;) do |ws|
  ws.add_row [&ldquo;Previous Year Quarterly Profits (JPY)&rdquo;]
  ws.add_row [&ldquo;Quarter&rdquo;, &ldquo;Profit&rdquo;, &ldquo;% of Total&rdquo;]
  offset = 3
  rows = 20
  offset.upto(rows + offset) do |i|</p>

<pre><code>ws.add_row ["Q#{i}", 10000*((rows/2-i) * (rows/2-i)), "=100*B#{i}/SUM(B3:B#{rows+offset})"], :style=&gt;[nil, money, percent]
</code></pre>

<p>  end</p>

<p>  color_scale = Axlsx::ColorScale.new
  ws.add_conditional_formatting(&ldquo;B3:B100&rdquo;, { :type => :colorScale, :operator => :greaterThan, :formula => &ldquo;100000&rdquo;, :dxfId => profitable, :priority => 1, :color_scale => color_scale })
end
```</p>

<p>大于100000的单元格颜色越来越深，而小于的单元格越来越浅。</p>

<h3>dataBar</h3>

<p>dataBar格式化能够在单元格中同时显示数值和一个柱形图，非常直观漂亮。</p>

<p><img src="http://f.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=435a969d3f6d55fbc1c676235d193e77/58ee3d6d55fbb2fb26dba2514d4a20a44723dc85.jpg?referer=b0f4797338f33a87c77a342a1c9b&amp;x=.jpg" alt="image" /></p>

<p>```ruby
book.add_worksheet(:name => &ldquo;Data Bar&rdquo;) do |ws|
  ws.add_row [&ldquo;Previous Year Quarterly Profits (JPY)&rdquo;]
  ws.add_row [&ldquo;Quarter&rdquo;, &ldquo;Profit&rdquo;, &ldquo;% of Total&rdquo;]
  offset = 3
  rows = 20
  offset.upto(rows + offset) do |i|</p>

<pre><code>ws.add_row ["Q#{i}", 10000*((rows/2-i) * (rows/2-i)), "=100*B#{i}/SUM(B3:B#{rows+offset})"], :style=&gt;[nil, money, percent]
</code></pre>

<p>  end</p>

<p>  data_bar = Axlsx::DataBar.new
  ws.add_conditional_formatting(&ldquo;B3:B100&rdquo;, { :type => :dataBar, :dxfId => profitable, :priority => 1, :data_bar => data_bar })
end
```</p>

<h3>iconSet</h3>

<p>iconSet方式是对于满足条件和不满足条件的单元格分别使用不同的图标。</p>

<p><img src="http://d.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=c718e589e4cd7b89ed6c3a863f1f339a/34fae6cd7b899e511cacdf5740a7d933c8950d56.jpg?referer=a0046022fa1986181850dab46b4d&amp;x=.jpg" alt="image" /></p>

<p>```ruby
book.add_worksheet(:name => &ldquo;Icon Set&rdquo;) do |ws|
  ws.add_row [&ldquo;Previous Year Quarterly Profits (JPY)&rdquo;]
  ws.add_row [&ldquo;Quarter&rdquo;, &ldquo;Profit&rdquo;, &ldquo;% of Total&rdquo;]
  offset = 3
  rows = 20
  offset.upto(rows + offset) do |i|</p>

<pre><code>ws.add_row ["Q#{i}", 10000*((rows/2-i) * (rows/2-i)), "=100*B#{i}/SUM(B3:B#{rows+offset})"], :style=&gt;[nil, money, percent]
</code></pre>

<p>  end</p>

<p>  icon_set = Axlsx::IconSet.new
  ws.add_conditional_formatting(&ldquo;B3:B100&rdquo;, { :type => :iconSet, :dxfId => profitable, :priority => 1, :icon_set => icon_set })
end
```</p>
]]></content>
  </entry>
  
</feed>
