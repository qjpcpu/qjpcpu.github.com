
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>深入ethereum源码-p2p模块基础结构 - Jason's space</title>
	<meta name="author" content="Jason">

	
	<meta name="description" content="(go-ethereum/p2p)包允许您快速方便地将对等网络添加到任何类型的应用程序。p2p包采用模块化结构,包含p2p网络节点通信维护及新节点发现,将网络结构的基础细节封装并向上层屏蔽,并且暴露了简单接口让上层实现子协议,上层应用使用自己的附加子协议扩展p2p非常简单直接. &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-113796486-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-113796486-1');
</script>

</head>


<body>
	<header id="header" class="inner"><h1><a href="/">Jason's space</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/blog/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/about">About</a></li>
</ul>

</nav>
<!--
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/blog/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/about">About</a></li>
</ul>

</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:qjpcpu.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="/search.html" method="get">
		<input class="search" type="text" name="query" x-webkit-speech/>
	</form>
</nav>
-->

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">深入ethereum源码-p2p模块基础结构</h2>
	<div class="entry-content"><p>(go-ethereum/p2p)包允许您快速方便地将对等网络添加到任何类型的应用程序。p2p包采用模块化结构,包含p2p网络节点通信维护及新节点发现,将网络结构的基础细节封装并向上层屏蔽,并且暴露了简单接口让上层实现子协议,上层应用使用自己的附加子协议扩展p2p非常简单直接.</p>

<p>如果将以太坊的p2p类比做tcp协议,那么p2p暴露出来的子协议就类似http,使得以太坊能够在基础p2p基础上构建出whisper网络。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#peer-to-peer">Peer to peer</a></li>
  <li><a href="#peer">peer接入</a></li>
  <li><a href="#rlp">数据传输格式RLP</a></li>
  <li><a href="#section">总述</a></li>
  <li><a href="#section-1">参考文献</a></li>
</ul>

<h1 id="peer-to-peer">Peer to peer</h1>

<p>在深入了解前,最好先看看基于p2p包怎么实现一个自己子协议,建立对其的直观印象</p>

<blockquote>
  <p>下面示例来基于官方[Peer to peer]wiki文档(官方文档有个小bug, ^_^),详细参考文献</p>
</blockquote>

<p>启动一个p2p节点仅需要对<code>p2p.Server</code>做一些简单配置:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="nx">nodekey</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">GenerateKey</span><span class="p">()</span>
</span><span class="line"><span class="nx">srv</span> <span class="o">:=</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
</span><span class="line">    <span class="nx">Config</span><span class="p">:</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
</span><span class="line">        <span class="nx">MaxPeers</span><span class="p">:</span>   <span class="mi">10</span><span class="p">,</span>
</span><span class="line">        <span class="nx">PrivateKey</span><span class="p">:</span> <span class="nx">nodekey</span><span class="p">,</span>
</span><span class="line">        <span class="nx">Name</span><span class="p">:</span>       <span class="s">&quot;my node name&quot;</span><span class="p">,</span>
</span><span class="line">        <span class="nx">ListenAddr</span><span class="p">:</span> <span class="s">&quot;:30300&quot;</span><span class="p">,</span>
</span><span class="line">        <span class="nx">Protocols</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">p2p</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">{},</span>
</span><span class="line">        <span class="nx">NAT</span><span class="p">:</span>        <span class="nx">nat</span><span class="p">.</span><span class="nx">Any</span><span class="p">(),</span>   <span class="c1">// 支持内网穿透</span>
</span><span class="line">        <span class="nx">Logger</span><span class="p">:</span>     <span class="nx">log</span><span class="p">.</span><span class="nx">New</span><span class="p">(),</span>
</span><span class="line">    <span class="p">},</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样启动的节点仅包含了以太坊自身的基础协议:</p>

<p>要实现自己的子协议,就需要拓展<code>Protocols:  []p2p.Protocol{}</code>,实现自己的<code>p2p.Protocol</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">MyProtocol</span><span class="p">()</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Protocol</span> <span class="p">{</span>
</span><span class="line">	<span class="k">return</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">{</span>                                                          <span class="c1">// 1.</span>
</span><span class="line">		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&quot;MyProtocol&quot;</span><span class="p">,</span>                                                    <span class="c1">// 2.</span>
</span><span class="line">		<span class="nx">Version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>                                                               <span class="c1">// 3.</span>
</span><span class="line">		<span class="nx">Length</span><span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>                                                               <span class="c1">// 4.</span>
</span><span class="line">		<span class="nx">Run</span><span class="p">:</span>     <span class="kd">func</span><span class="p">(</span><span class="nx">peer</span> <span class="o">*</span><span class="nx">p2p</span><span class="p">.</span><span class="nx">Peer</span><span class="p">,</span> <span class="nx">ws</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">MsgReadWriter</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">},</span> <span class="c1">// 5.</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>一个子协议即一个<code>p2p.Protocol</code></li>
  <li>子协议名,需要唯一标识该子协议</li>
  <li>协议版本号,当一个子协议有多个版本时,采纳最高版本的协议</li>
  <li>该协议拥有的消息类型个数,因为p2p网络是可扩展的，因此其需要具有能够发送随意个数的信息的能力（需要携带type，在下文中我们能够看到说明）,p2p的handler需要知道应该预留多少空间以用来服务你的协议。这是也是共识信息能够通过message ID到达各个peer并实现协商的保障。我们的协议仅仅支持一种类型</li>
  <li>在你的协议主要的handler中，我们现在故意将其留空。这个peer变量是指代连接到当前节点，其携带了一些peer本身的信息。其ws变量是reader和writer允许你同该peer进行通信，如果信息能够发送到当前节点，则反之也能够从本节点发送到对端peer节点</li>
</ol>

<p>现在让我们将前面留空的handler代码实现，以让它能够同别的peer通信:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">const</span> <span class="nx">messageId</span> <span class="p">=</span> <span class="mi">0</span>   <span class="c1">// 1.</span>
</span><span class="line"><span class="kd">type</span> <span class="nx">Message</span> <span class="kt">string</span>   <span class="c1">// 2.</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">msgHandler</span><span class="p">(</span><span class="nx">peer</span> <span class="o">*</span><span class="nx">p2p</span><span class="p">.</span><span class="nx">Peer</span><span class="p">,</span> <span class="nx">ws</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">MsgReadWriter</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">msg</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ws</span><span class="p">.</span><span class="nx">ReadMsg</span><span class="p">()</span>   <span class="c1">// 3.</span>
</span><span class="line">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>            <span class="c1">// 4.</span>
</span><span class="line">            <span class="k">return</span> <span class="nx">err</span> <span class="c1">// if reading fails return err which will disconnect the peer.</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="kd">var</span> <span class="nx">myMessage</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="nx">Message</span>
</span><span class="line">        <span class="nx">err</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">myMessage</span><span class="p">)</span> <span class="c1">// 5.</span>
</span><span class="line">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">            <span class="c1">// handle decode error</span>
</span><span class="line">            <span class="k">continue</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">switch</span> <span class="nx">myMessage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
</span><span class="line">        <span class="k">case</span> <span class="s">&quot;foo&quot;</span><span class="p">:</span>
</span><span class="line">            <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">SendItems</span><span class="p">(</span><span class="nx">ws</span><span class="p">,</span> <span class="nx">messageId</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1">// 6.</span>
</span><span class="line">            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">                <span class="k">return</span> <span class="nx">err</span> <span class="c1">// return (and disconnect) error if writing fails.</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">         <span class="k">default</span><span class="p">:</span>
</span><span class="line">             <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;recv:&quot;</span><span class="p">,</span> <span class="nx">myMessage</span><span class="p">)</span>
</span><span class="line">         <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="kc">nil</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>其中有且唯一的已知信息ID；</li>
  <li>将Messages alias 为string类型；</li>
  <li>ReadMsg将一直阻塞等待，直到其收到了一条新的信息，一个错误或者EOF；</li>
  <li>如果在读取流信息的过程当中收到了一个错误，最好的解决实践是将其返回给p2p server进行处理。这种错误通常是对端节点已经断开连接；</li>
  <li>msg包括两个属性和一个decode方法
    <ol>
      <li>Code 包括了信息ID，Code == messageId (i.e.0)</li>
      <li>Payload 是信息的内容</li>
      <li>Decode(<ptr>) 是一个工具方法：取得 msg.Payload并将其解码，并将其内容设置到传入的message指针中，如果失败了则返回一个error</ptr></li>
    </ol>
  </li>
  <li>如果解码出来的信息是foo将发回一个NewMessage并用messageId标记信息类型，信息内容是bar；而bar信息在被对端收到之后将被defaultcase捕获。</li>
</ol>

<p>现在，我们将上述的所有部分整合起来，得到下面的p2p样例代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kn">package</span> <span class="nx">main</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="p">(</span>
</span><span class="line">	<span class="s">&quot;fmt&quot;</span>
</span><span class="line">	<span class="s">&quot;github.com/ethereum/go-ethereum/crypto&quot;</span>
</span><span class="line">	<span class="s">&quot;github.com/ethereum/go-ethereum/log&quot;</span>
</span><span class="line">	<span class="s">&quot;github.com/ethereum/go-ethereum/p2p&quot;</span>
</span><span class="line">	<span class="s">&quot;github.com/ethereum/go-ethereum/p2p/discover&quot;</span>
</span><span class="line">	<span class="s">&quot;github.com/ethereum/go-ethereum/p2p/nat&quot;</span>
</span><span class="line">	<span class="s">&quot;net&quot;</span>
</span><span class="line">	<span class="s">&quot;os&quot;</span>
</span><span class="line"><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kd">const</span> <span class="nx">messageId</span> <span class="p">=</span> <span class="mi">0</span>
</span><span class="line">
</span><span class="line"><span class="kd">type</span> <span class="nx">Message</span> <span class="kt">string</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">MyProtocol</span><span class="p">()</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Protocol</span> <span class="p">{</span>
</span><span class="line">	<span class="k">return</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">{</span>
</span><span class="line">		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&quot;MyProtocol&quot;</span><span class="p">,</span>
</span><span class="line">		<span class="nx">Version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class="line">		<span class="nx">Length</span><span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
</span><span class="line">		<span class="nx">Run</span><span class="p">:</span>     <span class="nx">msgHandler</span><span class="p">,</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">	<span class="nx">nodekey</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">GenerateKey</span><span class="p">()</span>
</span><span class="line">	<span class="nx">logger</span> <span class="o">:=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">New</span><span class="p">()</span>
</span><span class="line">	<span class="nx">logger</span><span class="p">.</span><span class="nx">SetHandler</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">StderrHandler</span><span class="p">)</span>
</span><span class="line">	<span class="nx">srv</span> <span class="o">:=</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
</span><span class="line">		<span class="nx">Config</span><span class="p">:</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
</span><span class="line">			<span class="nx">MaxPeers</span><span class="p">:</span>   <span class="mi">10</span><span class="p">,</span>
</span><span class="line">			<span class="nx">PrivateKey</span><span class="p">:</span> <span class="nx">nodekey</span><span class="p">,</span>
</span><span class="line">			<span class="nx">Name</span><span class="p">:</span>       <span class="s">&quot;my node name&quot;</span><span class="p">,</span>
</span><span class="line">			<span class="nx">ListenAddr</span><span class="p">:</span> <span class="s">&quot;:30300&quot;</span><span class="p">,</span>
</span><span class="line">			<span class="nx">Protocols</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">p2p</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">{</span><span class="nx">MyProtocol</span><span class="p">()},</span>
</span><span class="line">			<span class="nx">NAT</span><span class="p">:</span>        <span class="nx">nat</span><span class="p">.</span><span class="nx">Any</span><span class="p">(),</span>
</span><span class="line">			<span class="nx">Logger</span><span class="p">:</span>     <span class="nx">logger</span><span class="p">,</span>
</span><span class="line">		<span class="p">},</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">Start</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">		<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span><span class="line">		<span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;started..&quot;</span><span class="p">,</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">NodeInfo</span><span class="p">())</span>
</span><span class="line">	<span class="k">select</span> <span class="p">{}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kd">func</span> <span class="nx">msgHandler</span><span class="p">(</span><span class="nx">peer</span> <span class="o">*</span><span class="nx">p2p</span><span class="p">.</span><span class="nx">Peer</span><span class="p">,</span> <span class="nx">ws</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">MsgReadWriter</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span><span class="line">	<span class="k">for</span> <span class="p">{</span>
</span><span class="line">		<span class="nx">msg</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ws</span><span class="p">.</span><span class="nx">ReadMsg</span><span class="p">()</span>
</span><span class="line">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">			<span class="k">return</span> <span class="nx">err</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">
</span><span class="line">		<span class="kd">var</span> <span class="nx">myMessage</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="nx">Message</span>
</span><span class="line">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">myMessage</span><span class="p">)</span>
</span><span class="line">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">			<span class="c1">// handle decode error</span>
</span><span class="line">			<span class="k">continue</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">
</span><span class="line">		<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;code:&quot;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Code</span><span class="p">,</span> <span class="s">&quot;receiver at:&quot;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">ReceivedAt</span><span class="p">,</span> <span class="s">&quot;msg:&quot;</span><span class="p">,</span> <span class="nx">myMessage</span><span class="p">)</span>
</span><span class="line">		<span class="k">switch</span> <span class="nx">myMessage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
</span><span class="line">		<span class="k">case</span> <span class="s">&quot;foo&quot;</span><span class="p">:</span>
</span><span class="line">			<span class="nx">err</span> <span class="o">:=</span> <span class="nx">p2p</span><span class="p">.</span><span class="nx">SendItems</span><span class="p">(</span><span class="nx">ws</span><span class="p">,</span> <span class="nx">messageId</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">)</span>
</span><span class="line">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">				<span class="k">return</span> <span class="nx">err</span>
</span><span class="line">			<span class="p">}</span>
</span><span class="line">		<span class="k">default</span><span class="p">:</span>
</span><span class="line">			<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;recv:&quot;</span><span class="p">,</span> <span class="nx">myMessage</span><span class="p">)</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="peer">peer接入</h1>

<p>从上面的例子,我们可以看出来实现ethereum是非常便利的,那么下一步,我们可以看看一个节点是怎么处理新peer的接入的?梳理出这个接入过程,也就明白了节点间基本的数据流通方式.</p>

<p>首先,每个节点启动入口都在<code>func (srv *Server) Start() (err error)</code>.该函数调用<code>srv.startListening()</code>在传入的ip地址监听tcp连接:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nx">startListening</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// Launch the TCP listener.</span>
</span><span class="line">    <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">ListenAddr</span><span class="p">)</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">listenLoop</span><span class="p">()</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="c1">// 主执行逻辑</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">dialer</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="kc">nil</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当接收到一个新的tcp连接,节点开始检查并初始化peer</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nx">setupConn</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">connFlag</span><span class="p">,</span> <span class="nx">dialDest</span> <span class="o">*</span><span class="nx">discover</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="c1">// 从这里开始,其实已经开始了ethereum的自有协议,doEncHandshake是RLPX协议的握手方法</span>
</span><span class="line">    <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">doEncHandshake</span><span class="p">(</span><span class="nx">srv</span><span class="p">.</span><span class="nx">PrivateKey</span><span class="p">,</span> <span class="nx">dialDest</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">srv</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Trace</span><span class="p">(</span><span class="s">&quot;Failed RLPx handshake&quot;</span><span class="p">,</span> <span class="s">&quot;addr&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fd</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">(),</span> <span class="s">&quot;conn&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">flags</span><span class="p">,</span> <span class="s">&quot;err&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="nx">err</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="c1">// 两次握手消息代码(handshakeMsg = 0x00)和(discMsg = 0x01)</span>
</span><span class="line">    <span class="nx">phs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">doProtoHandshake</span><span class="p">(</span><span class="nx">srv</span><span class="p">.</span><span class="nx">ourHandshake</span><span class="p">)</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="c1">// 握手完毕,将新连接对象*p2p.conn压入server.addpeer</span>
</span><span class="line">    <span class="nx">err</span> <span class="p">=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">checkpoint</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">addpeer</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// If the checks completed successfully, runPeer has now been</span>
</span><span class="line">    <span class="c1">// launched by run.</span>
</span><span class="line">    <span class="k">return</span> <span class="kc">nil</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下面开始看<code>Start()</code>函数里的节点主逻辑,主逻辑位于<code>Start()</code>末尾的<code>srv.run()</code>,该函数逻辑较复杂,我们现在主要看新peer接入的代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nx">run</span><span class="p">(</span><span class="nx">dialstate</span> <span class="nx">dialer</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="o">...</span>
</span><span class="line">      <span class="k">select</span><span class="p">{</span>
</span><span class="line">          <span class="o">...</span>
</span><span class="line">          <span class="k">case</span> <span class="nx">c</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">srv</span><span class="p">.</span><span class="nx">addpeer</span><span class="p">:</span>  <span class="c1">// 在这里取出之前压入addpeer的连接对象conn</span>
</span><span class="line">          <span class="c1">// 执行到这里表明握手完成,并且通过了节点验证</span>
</span><span class="line">          <span class="nx">err</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">protoHandshakeChecks</span><span class="p">(</span><span class="nx">peers</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span><span class="line">          <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">              <span class="c1">// 创建节点peer对象,传入所有子协议实现,自己实现的子协议就是在这里传入peer的,传入的所以协议通过matchProtocols函数格式化组织</span>
</span><span class="line">              <span class="nx">p</span> <span class="o">:=</span> <span class="nx">newPeer</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">Protocols</span><span class="p">)</span>
</span><span class="line">              <span class="o">...</span>
</span><span class="line">              <span class="k">go</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">runPeer</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span><span class="line">          <span class="p">}</span>
</span><span class="line">          <span class="o">...</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="o">...</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里补充说一下<code>newPeer()</code>对子协议的一个组织方式:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="nx">matchProtocols</span><span class="p">(</span><span class="nx">protocols</span> <span class="p">[]</span><span class="nx">Protocol</span><span class="p">,</span> <span class="nx">caps</span> <span class="p">[]</span><span class="nx">Cap</span><span class="p">,</span> <span class="nx">rw</span> <span class="nx">MsgReadWriter</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">protoRW</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// 按协议(name asc,version asc)排序子协议</span>
</span><span class="line">    <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">capsByNameAndVersion</span><span class="p">(</span><span class="nx">caps</span><span class="p">))</span>
</span><span class="line">    <span class="c1">// 自定义协议偏移</span>
</span><span class="line">    <span class="nx">offset</span> <span class="o">:=</span> <span class="nx">baseProtocolLength</span>
</span><span class="line">    <span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">protoRW</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nx">outer</span><span class="p">:</span>
</span><span class="line">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">caps</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">proto</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">protocols</span> <span class="p">{</span>
</span><span class="line">            <span class="k">if</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">Name</span> <span class="o">==</span> <span class="nx">cap</span><span class="p">.</span><span class="nx">Name</span> <span class="o">&amp;&amp;</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">Version</span> <span class="o">==</span> <span class="nx">cap</span><span class="p">.</span><span class="nx">Version</span> <span class="p">{</span>
</span><span class="line">                <span class="c1">// If an old protocol version matched, revert it</span>
</span><span class="line">                <span class="k">if</span> <span class="nx">old</span> <span class="o">:=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">cap</span><span class="p">.</span><span class="nx">Name</span><span class="p">];</span> <span class="nx">old</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span><span class="line">                    <span class="nx">offset</span> <span class="o">-=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">Length</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">                <span class="c1">// Assign the new match</span>
</span><span class="line">                <span class="nx">result</span><span class="p">[</span><span class="nx">cap</span><span class="p">.</span><span class="nx">Name</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">protoRW</span><span class="p">{</span><span class="nx">Protocol</span><span class="p">:</span> <span class="nx">proto</span><span class="p">,</span> <span class="nx">offset</span><span class="p">:</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">in</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Msg</span><span class="p">),</span> <span class="nx">w</span><span class="p">:</span> <span class="nx">rw</span><span class="p">}</span>
</span><span class="line">                <span class="nx">offset</span> <span class="o">+=</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">Length</span>
</span><span class="line">
</span><span class="line">                <span class="k">continue</span> <span class="nx">outer</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nx">result</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最终每个子协议以<code>name=&gt;protocol</code>的map格式组织起来,然后每个协议根据自身支持消息类型数量<code>Protocol.Length</code>在整个以太坊消息类型轴上占据了<code>[proto.offset,proto.offset+proto.Length)</code>的左闭右开消息类型段,理解这个结构,才好理解最终根据消息类型<code>Msg.Code</code>去找handler的逻辑(<code>func (p *Peer) getProto(code uint64) (*protoRW, error)</code>)。</p>

<p>下面继续看最终peer处理逻辑<code>srv.runPeer</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="go"><span class="line"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Peer</span><span class="p">)</span> <span class="nx">run</span><span class="p">()</span> <span class="p">(</span><span class="nx">remoteRequested</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line">    <span class="c1">// peer逻辑里最重要两个循环逻辑</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 收取消息循环,核心逻辑是根据消息的代号proto, err := p.getProto(msg.Code),</span>
</span><span class="line">    <span class="c1">// 取得对应的子协议,然后投放到对应协议的读队列proto.in &lt;- msg</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">p</span><span class="p">.</span><span class="nx">readLoop</span><span class="p">(</span><span class="nx">readErr</span><span class="p">)</span>
</span><span class="line">    <span class="c1">// 不停发送ping心跳包到远端peer</span>
</span><span class="line">    <span class="k">go</span> <span class="nx">p</span><span class="p">.</span><span class="nx">pingLoop</span><span class="p">()</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 在startProtocols里最终调用我们自定义子协议的Run方法proto.Run(p, rw)</span>
</span><span class="line">    <span class="nx">p</span><span class="p">.</span><span class="nx">startProtocols</span><span class="p">(</span><span class="nx">writeStart</span><span class="p">,</span> <span class="nx">writeErr</span><span class="p">)</span>
</span><span class="line">    <span class="o">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="rlp">数据传输格式RLP</h1>

<p>以太坊数据传输都是基于RLP编码,下面文字摘自<a href="http://ethfans.org/posts/415">RLP编码原理</a></p>

<blockquote>
  <p>RLP(Recursive Length Prefix，递归长度前缀)是一种编码算法，用于编码任意的嵌套结构的二进制数据，它是以太坊中数据序列化/反序列化的主要方法，区块、交易等数据结构在持久化时会先经过RLP编码后再存储到数据库中</p>
</blockquote>

<p>定义</p>

<blockquote>
  <p>RLP编码的定义只处理两类数据：一类是字符串（例如字节数组），一类是列表。字符串指的是一串二进制数据，列表是一个嵌套递归的结构，里面可以包含字符串和列表，例如<code>["cat",["puppy","cow"],"horse",[[]],"pig",[""],"sheep"]</code>就是一个复杂的列表。其他类型的数据需要转成以上的两类，转换的规则不是RLP编码定义的，可以根据自己的规则转换，例如struct可以转成列表，int可以转成二进制（属于字符串一类），以太坊中整数都以大端形式存储。</p>
</blockquote>

<p>这部分代码均位于<code>github.com/ethereum/go-ethereum/rlp</code>包中,代码相对独立,我也没深入研究改算法,就不详细说明了。</p>

<h1 id="section">总述</h1>

<p>本文主要梳理了以太坊p2p模块的主流程,描述了核心的peer间数据读写的来龙去脉,从代码里也能够比较容易理解以太坊子协议的概念,理清这个主干流程,以后也就能够从每个细节发散开来,深入细节。</p>

<h1 id="section-1">参考文献</h1>

<ul>
  <li><a href="https://github.com/ethereum/go-ethereum">go-ethereum github地址</a></li>
  <li><a href="https://github.com/ethereum/go-ethereum/wiki/Peer-to-Peer">Peer to Peer</a></li>
  <li><a href="http://blog.csdn.net/teaspring/article/details/78455046">基于p2p的底层通信</a></li>
  <li><a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-RLP">RLP</a></li>
  <li><a href="http://ethfans.org/posts/415">RLP编码原理</a></li>
</ul>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2018-01-29T11:19:23+08:00" pubdate data-updated="true">Jan 29<span>th</span>, 2018</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/blockchain/'>blockchain</a>


</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		<a class="addthis_button_tweet"></a>
		
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    Jason

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'qjpcpugithubio';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/';
        var disqus_url = 'http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>